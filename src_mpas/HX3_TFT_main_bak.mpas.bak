{*
 * Project name:
     HX3_TFT.vtft
 * Generated by:
     Visual TFT
 * Date of creation
     20.04.2022
 * Test configuration:
     MCU:             STM32F407ZG
     Dev.Board:       HX36
     Oscillator:      72000000 Hz
     SW:              mikroPascal PRO for ARM
 *}

// #############################################################################
//       __ ________  _____  ____  ___   ___  ___
//      / //_/ __/\ \/ / _ )/ __ \/ _ | / _ \/ _ \
//     / ,< / _/   \  / _  / /_/ / __ |/ , _/ // /
//    /_/|_/___/_  /_/____/\____/_/_|_/_/|_/____/
//      / _ \/ _ | / _ \/_  __/ |/ / __/ _ \
//     / ___/ __ |/ , _/ / / /    / _// , _/
//    /_/  /_/ |_/_/|_| /_/ /_/|_/___/_/|_|
//
// #############################################################################


// #############################################################################

//    MCU:             STM32F103RET6
//    Dev.Board:       Fusion_STM32_ARM_FT800_Port_CH
//    Oscillator:      72000000 Hz
//    SW:              mikroPascal PRO for ARM v6.20


// TFT Calibration Constants, 6 Messungen
// A:00008055, B:00000000, C:FFF35790, D:FFFFFF9F, E:00004CD2, F:FFF21104
// A:00008190, B:0000003D, C:FFF11DC5, D:FFFFFD04, E:00004DC0, F:FFF40D5A
// A:00008035, B:00000096, C:FFF29983, D:FFFFFEB4, E:00004C0B, F:FFF4B477
// A:00008106, B:FFFFFF4A, C:FFF1DC32, D:FFFFFE36, E:00004CD5, F:FFF57398
// A:0000801A, B:000000D9, C:FFF07056, D:FFFFFF67, E:00004EC8, F:FFEBE6C0
// A:0000815B, B:FFFFFFA4, C:FFF0059D, D:FFFFFE77, E:00004D53, F:FFF2143D

program HX3_TFT_main;

uses parser, lcd_twi, spi_rw, twi_systimer, const_def, sd_card, fpga_hilevel,
     apply_changes, dataflash, switch_if, menu_system, save_restore;

var
    // vector_table: array[0..127] of DWord; absolute c_vector_start;
    current_duty, temp_w, idx: word;
    pwm_period : word;
    enc_value: Integer;

const RESET_VECTOR_SIZE: byte  = 20;   // MCU reset vector size in bytes.

procedure MainTasks;
// benutzte LCs
// (6)  HP-Filter,
// (8)  DB Upper,
// (9)  DB Lower,
// (10) DB Pedal,
// (11) ADSR Upper,
// (12) ADSR Lower,
// (13) ADSR Pedal
var
  temp_buttons: Byte;
  idx: Word;
begin
  // Event aufgetreten?
  case IRQ_roundrobin of

  0:
    begin
      SWI_HandlePanel(0, false);
      SWI_HandlePanel(1, false);
    end;
  1:
    begin
      SWI_HandlePanel(2, false);
      SWI_HandlePanel(3, false);
    end;
  2:
    begin
      SWI_HandlePanel(4, false);
      SWI_HandlePanel(5, false);
      SWI_HandlePanel(7, false);  // XB2-Panel
    end;
  6:
    begin
      SWI_HandleVibratoKnob;
      MenuPanelHandling;   // Aufruf sollte vor AC_ExecEditChanges erfolgen!
    end;
  7:
    begin
      AC_ExecEditChanges;
      if SendPromptRequest then
        Serial1_sendChar(#62);  // '>' Prompt nach jedem Befehl
      SendPromptRequest:= false;
    end;
  end;
  ADC_ReadSwell; // Port PA.0
  AC_SendSwell;  // spontate Reaktion auf Schweller erforderlich, alle 2ms
end;

procedure InitMain();
  var int_reg: DWord;
begin
  int_reg:= DisableInterrupts;

  PortInit(); // in var_def.mpas

  LEDcard:= true;

  SysTimerInit;
  // Initialize USART modules at 57600 bps
  Serial1_Init();   // FTDI-Kabel
  Serial2_Init();   // WIFI-Modul

  RestoreInterrupts(int_reg);  // bevor irgendetwas ausgegeben wird!

  TWI_Init;
  // Warte auf FPGA-Konfiguration
  SPI_fpga_init(false);  // nur warten, kein F_PROG

  InitMsgEnable:= true;        // Ausgabe von Init-Meldungen beim Start

  LCD_TWI_Init;

  QFL_RST:= true;    // SAM-Flash Reset aufheben
  SAM_RST:= true;    // SAM-MCU Reset aufheben
  BT_RST:=  true;    // WIFI Reset aufheben
  TFT_PWRDN:= true;  // EVT TFT Reset aufheben

  WordToStr(Clock_MHz(), val_str);
  ltrim(val_str);
  Serial1_sendstringCRLF('');
  Serial1_sendstringCRLF(s_divline);
  Serial1_sendstringCRLF('/ ' + s_SysExDeviceStr);
  Serial1_sendstringCRLF('/ STM32F103R MCU ' + val_str);

  SD_Init;   // SD-SPI, SD vorhanden?
  Serial1_sendstringCRLF(s_divline);

  if LCD_TWI_present and InitMsgEnable then
    Serial1_sendstringCRLF('/ LCD found');
  SWI_Init;
  EDIT_Init; // Defaults laden

  DF_LoadScanDriver;
  DF_LoadFIRcoeff;
  // DF_LoadTapering(edit_TG_TaperCaps); // wird in AC_Init erledigt
  // DF_LoadWaveset(edit_TG_WaveSet);    // wird in AC_Init erledigt

  LCD_TWI_WriteStr(s_LCD1Str);
  LCD_TWI_XY(0, 1);
  LCD_TWI_WriteStr(val_str + ' MHz');

  // Default-Werte initialisieren und senden
  PA_Init;
  SR_Init; // EEPROM-Bereich und Voiceblock aus DF laden, vor AC_Init!
  ADC_Init;
  AC_Init;
  MenuInit;
  FH_BoardInfo;
  Serial1_sendstringCRLF(s_divline);
  SendPromptRequest:= true;             // Bereitschafts-Prompt
end;

// #############################################################################

begin
{$IFDEF USE_BOOTLOADER}
  // Nach Kompilierung der Firmware befindet sich die Vektortabelle
  // im Binary immer auf $00000000, egal was bei ORG[all] vermerkt ist.
  // Gelesener Firmware-Block 0 aus DF wird daher im Bootloader
  // auf Adresse VEC_TABLE_START geschrieben, Bootloader setzt
  // Vektortabellen-Adresse vor dem Einsprung in Firmware auf diesen Wert.

  // Einsprungpunkt des Bootloaders, Reset-Vektor in NVIC-Tabelle $00000004:
  org(FIRMWARE_START);
  // Sorgt dafür, dass nichts vor Adresse BOOTLOADER_START platziert wird:
  orgall(FIRMWARE_START); // 48K für Bootloader
{$ELSE}
  // Einsprungpunkt des Bootloaders, Reset-Vektor in NVIC-Tabelle $00000004:
  org(BOOTLOADER_START);
  // Sorgt dafür, dass nichts vor Adresse BOOTLOADER_START platziert wird:
  orgall(BOOTLOADER_START);
{$ENDIF}

{$IFDEF USE_EVETFT}
  InitVTFTStack();
{$ENDIF}
  InitMain();

  while true do begin
{$IFDEF USE_EVETFT}
    ProcessVTFTStack();
{$ENDIF}
    PA_CheckSer;
    if IRQ_sema then begin
      MainTasks;
      IRQ_sema:= false;
    end;
  end;
end.