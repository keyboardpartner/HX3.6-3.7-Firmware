// #############################################################################
//       __ ________  _____  ____  ___   ___  ___
//      / //_/ __/\ \/ / _ )/ __ \/ _ | / _ \/ _ \
//     / ,< / _/   \  / _  / /_/ / __ |/ , _/ // /
//    /_/|_/___/_  /_/____/\____/_/_|_/_/|_/____/
//      / _ \/ _ | / _ \/_  __/ |/ / __/ _ \
//     / ___/ __ |/ , _/ / / /    / _// , _/
//    /_/  /_/ |_/_/|_| /_/ /_/|_/___/_/|_|
//
// #############################################################################

// ADC Interface: Handling analoger Eingänge

// |-----------------------------User Activity---------------------------------|
// |--MenuSystem--|--SwitchIF--|--AnalogInputs--|--MIDI Dispatch--|---Parser---|
// |---------------------------Event/Edit Array--------------------------------|
// |----------------------------Apply Changes----------------------------------|
// |---FPGA Hilevel---|---MIDI Send---|--Binary Send (WIFI)--|--Store/Recall---|
// |-----------------------------Hardware-----------------------|-->-Events-^--|

unit adc_handling;

uses var_def, events, edit_vals, const_def, edit_offsets, avrco_compat, serial1, twi_systimer, switch_if;

  procedure ADC_ReadAll_24;    // 24 interne Inputs holen und auf edit-Tabelle verteilen
  procedure ADC_ReadAll_64;    // 64 externe Inputs holen und auf edit-Tabelle verteilen
  procedure ADC_ReadAndChangesToEdit;

  // ADCs freigeben wenn true, erzwingt spätere Aktualisierung
  // ADCs unempfindlich wenn false
  procedure ADC_SetActiveAll(active: Boolean);
  procedure ADC_SetActiveUpper(active: Boolean);
  procedure ADC_SetActiveLower(active: Boolean);
  procedure ADC_SetActivePedal(active: Boolean);
  
  procedure ADC_Init;   // Remap-Table anlegen, ADC-Werte annulieren
  function ADC_GetSwell: Word;  // Nur Schweller lesen, getrennter AVR-Eingang



implementation

const
  c_ADC_hyst_timeout: Integer = 25;
  c_ADC_hyst_minimum_active: Integer = 2;
  c_ADC_hyst_minimum_idle: Integer = 3;

var
  idx: Word;
  adc_swell_old, adc_swell_integrator: Word;

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ADC-Remap über Tabelle: Index ADC-Kanal, Ausgang edit_Table-Index
// 100..108: Secondary DB Set 1, gleiche Werte wie 0..9    (für DBX9)
// 112..120: Secondary DB Set 2, gleiche Werte wie 12..21  (für DBX9)
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  adc_changed: Array[0..127] of boolean;  // Flags: Analog-Wert hat sich geändert
  adc_hyst_timers : Array[0..127] of Integer;  // Hysterese-Timer

// #############################################################################

procedure adc_set_timer_range(remapped_start, remapped_end: Byte; active: Boolean);
// Durchsucht ADC_remaps nach Werten zwischen db_start und db_end
// und setzt deren analoge Eingänge und Timer auf "active"-Wert
// Wird bei Voice-Umschaltung von Preset auf Live aufgerufen
var my_remap: Byte;
begin
  if edit_ADCconfig >= 2 then // ADC eingeschaltet?
    for idx:= 0 to 120 do begin
      my_remap:=  eep_AnalogRemaps[idx] and $7F;
      if valueInRange(my_remap, remapped_start, remapped_end) then begin
        // Timer abgelaufen, grobe Hysterese
        if active then
          adc_hyst_timers[idx]:= c_ADC_hyst_timeout // noch aktiv
        else
          adc_hyst_timers[idx]:= 0; // in Ruhe
        adc_changed[idx]:= active;  // Force or disable ADC handling
      end;
    end;
end;

procedure ADC_SetActiveAll(active: Boolean);
// Alle ADCs freigeben/sperren, erzwingt spätere Aktualisierung wenn TRUE
begin
  if edit_ADCconfig >= 2 then     // ADC eingeschaltet?
    for idx:= 0 to 127 do begin
      if active then
        adc_hyst_timers[idx]:= c_ADC_hyst_timeout // noch aktiv
      else
        adc_hyst_timers[idx]:= 0; // in Ruhe
      adc_changed[idx]:= active;  // Force or disable ADC handling
    end;
end;

procedure ADC_SetActiveUpper(active: Boolean);
begin
  adc_set_timer_range(c_UpperDBs, c_UpperDBs + 11, active);    // DBs
end;

procedure ADC_SetActiveLower(active: Boolean);
begin
  adc_set_timer_range(c_LowerDBs, c_LowerDBs + 11, active);   // DBs
end;

procedure ADC_SetActivePedal(active: Boolean);
begin
  adc_set_timer_range(c_PedalDBs, c_PedalDBs + 11, active);   // DBs
  adc_set_timer_range(c_PedalDB4s, c_PedalDB4s + 3, active);  // DB4s
end;

// #############################################################################


procedure adc_read(adc_chan: Word);
// Schreibt in Tabelle ADC_Values, wenn Eingang sich stärker als
// Hysterese ändert. Dieser Eingang wird dann über Timer auf "aktiv" gesetzt
// und laufend in ADC_Values aktualisiert.
// Wert in ADC_Values speichern und ADC_changed-Flag setzen, sofern geändert
// liefert Remap-Wert zurück, der ohnehin gebraucht wird
// 18 µs für je jeden freigeschalteten Eingang im Leerlauf (nicht bedient)
// 20 µs, wenn Wert sich gerade ändert
// benutzt n
var
  adc_hyst, adc_val_old_i, adc_raw_i: Integer;
  timer_val_i: Integer;
  my_active : boolean;
begin
  // Einschwingzeit nutzen, Zeit bis zur Wandlung liegt insgesamt bei ca. 8 µs
  timer_val_i:= adc_hyst_timers[adc_chan];      // aktueller Aktiv-Timerwert in n
  if timer_val_i > 0 then begin
    // nicht abgelaufen, also aktiv
    dec(timer_val_i);
    my_active:= true;
    adc_hyst:= Integer(edit_ADChysteresis div 2) + c_ADC_hyst_minimum_active;  // halbe Hysterese
  end else begin
    // Timer abgelaufen, also idle
    timer_val_i:= 0;
    my_active:= false;                 
    adc_hyst:= Integer(edit_ADChysteresis) + c_ADC_hyst_minimum_idle;
  end;
  adc_hyst_timers[adc_chan]:= timer_val_i;    // Decrement speichern
  adc_val_old_i:= ADC_Values[adc_chan];       // vorheriger ADC-Wert
  
  adc_raw_i:= Integer(ADC1_Get_Sample(15) shr 4);

  // neuer Wert um grobe Hysterese größer oder kleiner als alter Wert?
  if (adc_raw_i > (adc_val_old_i + adc_hyst))
  or (adc_raw_i < (adc_val_old_i - adc_hyst)) then begin
    // Aktiv-Timer laden, 100=1,6 sek. bei 16ms Cycle (2ms Systick, 8 Timeslots)
    adc_hyst_timers[adc_chan]:= c_ADC_hyst_timeout;
    my_active:= true;
  end;
  
  if (adc_raw_i < adc_hyst) then
    adc_raw_i:= 0;
    
  // falls aktiv und geändert, neuen Wert und Flag in ADC-Array setzen
  if my_active then begin
    if (adc_raw_i <> adc_val_old_i) then
      adc_changed[adc_chan]:= true;
    ADC_Values[adc_chan]:= adc_raw_i; // letzter Wert für nächsten Vergleich
  end;
end;

// -----------------------------------------------------------------------------

procedure adc_disable;
begin
  MPX_CLR:= false;  // Reset HC164
  MPX_INH_1:= true; // 4051 A disable
  MPX_INH_2:= true;
  MPX_INH_3:= true;
end;

procedure adc_input_4051(input_ch: Word);
begin
  MPX_CLR:= false;  // Reset HC164, 4066 MXP sperren
  if input_ch <= 7 then
    MPX_INH_1:= false   // enable A
  else
    MPX_INH_1:= true;   // disable A
  if ValueInRange(input_ch, 8, 15) then
    MPX_INH_2:= false   // enable B
  else
    MPX_INH_2:= true;   // disable B
  if input_ch >= 16 then
    MPX_INH_3:= false   // enable C
  else
    MPX_INH_3:= true;   // disable C
  GPIOC_ODR:= (GPIOC_ODR and $FFF8) or (input_ch mod 8);
end;

procedure ADC_ReadAll_24;    // 24 interne Inputs holen und auf edit-Tabelle verteilen
var
  input_ch, adc_remap: Word;
begin
  adc_disable; // Reset HC164, 4051 disable
  for input_ch:= 0 to 23 do begin
    adc_input_4051(input_ch);
    adc_remap:= eep_AnalogRemaps[input_ch];
    if (adc_remap = c_map_end) and (not ADCtestMode) then
      break;
    if input_ch = 0 then begin
      Delay_us(2);  // Settle Time
      ADC1_Get_Sample(15); // dummy read, erster Wert springt sonst
    end;
    Delay_us(2);    // Settle Time
    adc_read(input_ch);
  end;
  adc_disable; // Reset HC164, 4051 disable
end;

procedure ADC_ReadAll_64;    // 64 externe Inputs holen und auf edit-Tabelle verteilen
var
  adc_chan, adc_remap: Word;
begin
  adc_disable;     // Reset HC164
  MPX_CLK:= false; // Clock
  MPX_CLR:= true;  // Reset HC164 aufheben, 4051 disabled
  // Startbit einschieben
  MPX_Q:= true;    // HC164 SER IN
  nop; nop;
  MPX_CLK:= true;  // HC164 CLK
  nop; nop;
  MPX_CLK:= false; // HC164 CLK
  MPX_Q:= false;   // HC164 SER IN
  // Jetzt erster HC164-Ausgang high
  for adc_chan:= 24 to 87 do begin
    adc_remap:= eep_AnalogRemaps[adc_chan];
    if (adc_remap = c_map_end) and (not ADCtestMode) then
      break;
    if adc_chan = 24 then begin
      Delay_us(1);    // Settle Time, geringer als bei 24er
      ADC1_Get_Sample(15); // dummy read, erster Wert springt sonst
    end;
    Delay_us(1);     // Settle Time, geringer als bei 24er
    adc_read(adc_chan);
    MPX_CLK:= true;  // HC164 CLK
    nop; nop;
    MPX_CLK:= false; // HC164 CLK
  end;
end;

// #############################################################################

procedure ADC_ChangeToRemap(adc_chan, adc_remap: Byte; log_pots: Boolean);
// TODO!  - Eder-Orgel
var
  adc_val, my_idx: Word;
  my_remap: Word;
  is_2nd_dbset_remap, is_db, is_upper_db, is_lower_db: Boolean;
begin
  adc_val:= (Word(ADC_Values[adc_chan]) * edit_ADCscaling) div 200; // auf 0..127
  if adc_val > 127 then
    adc_val:= 127;
  is_2nd_dbset_remap:= valueInRange(adc_remap, 128, 155); // Secondary-Flag, >=128
  my_remap:= adc_remap and $7F;
  is_upper_db:= valueInRange(my_remap, 0, 15);
  is_lower_db:= valueInRange(my_remap, 16, 27);
  is_db:= is_upper_db or is_lower_db;
  // Drawbars Upper, Lower
  if (is_2nd_dbset_remap or is_db) then begin
    if (edit_ADCconfig = 3) then begin
      // Upper/Lower DBX-Drawbars mit neuer 2nd-Set-Logik behandeln
      // DB-Levels ggf. sperren, wenn inaktiver DB-Satz
      if is_upper_db and (is_2nd_dbset_remap <> UpperSecondaryActive) then
          exit;  // nicht aktiv, überspringen
      if is_lower_db and (is_2nd_dbset_remap <> LowerSecondaryActive) then
          exit;  // nicht aktiv, überspringen
    end;
  end else if log_pots and valueInRange(adc_remap, 80, 95) then begin
    // Logarithmische Volume-Potentiometer?
    adc_val:= c_AntiLogTable[lo(adc_val)];
    NewEditIdxEvent(adc_remap, adc_val, c_control_event_source);
    exit;
  end else if valueInRange(adc_remap, 200, 211) then begin   // MIDI CC Remap?
    my_remap:= adc_remap - 200 + 1520; // MIDI CC Send Idx, 1520..1531
    NewParamEvent(my_remap, adc_val, c_control_event_source);
    exit;
  end else if valueInRange(adc_remap, 248, 250) then begin   // Rotary-DB-Remap?
    my_remap:= adc_remap - 248 + c_RotaryGroup_DB;
    NewEditIdxEvent(my_remap, adc_val, c_control_event_source);
    exit;
  end;

  // normale Zuordnung über Remap, kein Rotary-DB
  if edit_ADCconfig >= 4 then begin
    if SingleDBsetSelect = 1 then begin
      // Single DB9 umleiten wenn edit_ADCconfig = 4 und ToLower-Tab
      if is_upper_db then   // Upper DBs?
        // Änderungen auf Lower umleiten
        my_remap:= adc_remap + 16;
    end else if SingleDBsetSelect = 2 then begin
      case adc_remap of // Single DB9 umleiten wenn edit_ADCconfig = 4 und ToPedal-Tab
        0: my_remap:= 72;
        1: my_remap:= 74;
        2: my_remap:= 67
      else
        exit;
      end;
    end else if is_lower_db then   // Lower DBs?
      exit;  // Änderungen auf Lower-Eingängen verwerfen
  end;
//  Serial1_sendstringCRLF('/ ANLG EVT:');
//  Serial1_sendIntValCRLF(my_remap);
//  Serial1_sendIntValCRLF(adc_val);
  NewEditIdxEvent(my_remap, adc_val, c_control_event_source);
end;

procedure ADC_ReadAndChangesToEdit;
// benötigt etwa 430us für 88 Eingänge
var
  adc_chan, adc_remap, upper_keycount, lower_keycount: byte;
  log_pots: Boolean;
  adc_val: Integer;
begin
  if ADCtestMode then begin
    ADC_ReadAll_24;  // zusammen etwa 430us
    ADC_ReadAll_64;
    exit;
  end;
  if (edit_ADCconfig < 2) then
    exit;
  log_pots:= edit_ConfBits1.B5;

  ADC_ReadAll_24;
  for adc_chan:= 0 to 23 do begin
    adc_remap:= eep_AnalogRemaps[adc_chan];
    if adc_remap = c_map_none then
      continue;
    if adc_remap = c_map_end then
      break;
    if ADC_changed[adc_chan] then begin
      ADC_changed[adc_chan]:= false;
      ADC_ChangeToRemap(adc_chan, adc_remap, log_pots);
    end;
  end;

  ADC_ReadAll_64;
  for adc_chan:= 24 to 87 do begin
    adc_remap:= eep_AnalogRemaps[adc_chan];
    if adc_remap = c_map_none then
      continue;
    if adc_remap = c_map_end then
      break;
    if ADC_changed[adc_chan] then begin
      ADC_changed[adc_chan]:= false;
      ADC_ChangeToRemap(adc_chan, adc_remap, log_pots);
    end;
  end;
end;

// #############################################################################

function ADC_GetSwell: Word;  // Nur Schweller lesen, getrennter AVR-Eingang
// die Funktion liefert Werte von 0..255!
// Falls MIDI aktiv, liefert sie den aktuellen MIDI-Expression-Wert zurück
var
  swell_new: Word;
begin
  if edit_ADCconfig = 0 then begin
    SwellPedalControlledByMIDI:= true;
    swell_new:= 255;
  end else begin
    swell_new:= ADC1_Get_Sample(14) shr 4;
    if (swell_new > (adc_swell_old + 4)) or ((swell_new + 4) < adc_swell_old) then begin
      SwellPedalControlledByMIDI:= false;
      adc_swell_old:= swell_new;
    end;
  end;
  if SwellPedalControlledByMIDI then
    swell_new:= word(MIDIswell128 shl 1);
  result:= swell_new;
end;

// -----------------------------------------------------------------------------

procedure ADC_Init;     // Remap-Table anlegen, ADC-Werte annulieren
begin
  SingleDBsetSelect:= 0;
  ADC1_Init;
  ADC_Set_Input_Channel(_ADC_CHANNEL_14 or _ADC_CHANNEL_15);
  ADCtestMode:= false;
  adc_swell_old:= 255;
  ADC_GetSwell;
  adc_disable;
  UpperSecondaryActive:= false;
  UpperIsLive:= true;
  LowerSecondaryActive:=false;
  LowerIsLive:= true;
  if VibknobPortPresent then
    TWI_WriteRegB(PCA9554A_0, 1, $3F); // DB-Umschaltung alte DB9-MPX auf 00
  ADC_SetActiveAll(true);              // Force ADC update on boot
end;

end.