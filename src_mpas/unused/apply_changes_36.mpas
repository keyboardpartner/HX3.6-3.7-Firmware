// #############################################################################
//       __ ________  _____  ____  ___   ___  ___
//      / //_/ __/\ \/ / _ )/ __ \/ _ | / _ \/ _ \
//     / ,< / _/   \  / _  / /_/ / __ |/ , _/ // /
//    /_/|_/___/_  /_/____/\____/_/_|_/_/|_/____/
//      / _ \/ _ | / _ \/_  __/ |/ / __/ _ \
//     / ___/ __ |/ , _/ / / /    / _// , _/
//    /_/  /_/ |_/_/|_| /_/ /_/|_/___/_/|_|
//
// #############################################################################

// Apply Changes: Werte-Änderungen anwenden

// |-----------------------------User Activity---------------------------------|
// |--MenuSystem--|--SwitchIF--|--AnalogInputs--|--MIDI Dispatch--|---Parser---|
// |---------------------------Event/Edit Array--------------------------------|
// |----------------------------Apply Changes----------------------------------|
// |---FPGA Hilevel---|---MIDI Send---|--Binary Send (WIFI)--|--Store/Recall---|
// |-----------------------------Hardware-----------------------|----Events-^--|

unit apply_changes;

uses edit_vals, var_def, twi_systimer, const_def, fpga_hilevel, spi_rw, nuts_bolts,
     avrco_compat, events, edit_defaults, edit_offsets, switch_if,
     dataflash, menu_entries, switch_if, midi_com, osc_com,
     adc_handling, save_restore, serial1, serial2, ac_proc_idx, messages;


procedure AC_ExecEditChanges;
procedure AC_Init;
procedure AC_SendSwell;

// Load-Funktionen müssen VOR Handling der Event-Tabelle ausgeführt werden:
procedure AC_PresetChangeEvent(event_source: Word);
procedure AC_VoiceChangeUpperEvent(event_source: Word);
procedure AC_VoiceChangeLowerEvent(event_source: Word);
procedure AC_VoiceChangePedalEvent(event_source: Word);

procedure AC_HandleVoiceChangeUpper;
procedure AC_HandleVoiceChangeLower;
procedure AC_HandleVoiceChangePedal;

// Wrapper-Forwards für Proc-Tabelle:
procedure AC_HandleGatingknob;
procedure AC_HandleGatingButtons;
procedure AC_HandleVibknob;
procedure AC_HandleVibButtons;
procedure AC_HandleReverbKnob;
procedure AC_HandleReverbButtons;
procedure AC_HandlePercKnob;
procedure AC_HandlePercButtons;

procedure AC_SendMasterVolume;
procedure AC_SendVolumes;
procedure AC_OrganParamsToFPGA;
procedure AC_SendTrimPots;
procedure AC_SendLeslieLiveParams;
procedure AC_WaveBlocksToFPGA;
procedure AC_SendPHRprgm;  
procedure AC_PhasingRotorToFPGA;
procedure AC_SendUpperDBs;
procedure AC_SendLowerDBs;
procedure AC_SendPedalDBs;
procedure AC_SendConvertedPedalDBs;
procedure AC_SendTaper;
procedure AC_RouteDirect;
procedure AC_SendGating;
procedure AC_SendInserts;
procedure AC_SendGM2ena;
procedure AC_SendRotarySpeed;
procedure AC_SendMIDIccSet;
procedure AC_SetDetent;
procedure AC_SendReverb;
procedure AC_SendPercValues;
procedure AC_SendGMvoiceUpper0;
procedure AC_SendGMvoiceUpper1;
procedure AC_SendGMupperLvl;
procedure AC_SendGMvoiceLower0;
procedure AC_SendGMvoiceLower1;
procedure AC_SendGMlowerLvl;
procedure AC_SendGMvoicePedal0;
procedure AC_SendGMvoicePedal1;
procedure AC_SendGMpedalLvl;
procedure AC_VibratoToFPGA;
procedure AC_SendTuningVals;
procedure AC_SetLEDdimmer;
procedure AC_SplitConfigToFPGA;

implementation

// Event-Funktion über Tabelle
type
  t_eventproc = procedure;
  
const
  // Tabelle IncDec-Button-Offset (div 2) auf Parameter
  c_incdec2edit_idx: Array[0..7] of Word = (
    // alle IncDec-Buttons #1192..#1207 (Index div 2)
    // Presets, 3x Voices, 2x Models, Transpose, RFU
    c_CommonPreset, c_UpperVoice, c_LowerVoice, c_PedalVoice, 
    c_OrganModel, c_RotaryModel, c_GenTranspose, 0 );
    
  c_incdec_lastbtn: byte = 13;   // Anzahl der Inc/Dec-Buttons #1192..#1207 -1

  c_proc_max = 46;

  ac_event_procs: Array[0..c_proc_max] of ^t_eventproc = (
    @AC_HandleGatingknob,  // Index [0]
    @AC_HandleGatingButtons,  // Index [1]
    @AC_HandleVibknob,  // Index [2]
    @AC_HandleVibButtons,  // Index [3]
    @AC_HandleReverbKnob,  // Index [4]
    @AC_HandleReverbButtons,  // Index [5]
    @AC_HandlePercKnob,  // Index [6]
    @AC_HandlePercButtons,  // Index [7]
    @AC_HandleVoiceChangeUpper,  // Index [8]
    @AC_HandleVoiceChangeLower,  // Index [9]
    @AC_HandleVoiceChangePedal,  // Index [10]
    @AC_SendTaper,  // Index [11]
    @AC_WaveBlocksToFPGA,  // Index [12]
    @AC_SendTuningVals,  // Index [13]
    @AC_SendGating,  // Index [14]
    @AC_OrganParamsToFPGA,  // Index [15]
    @AC_SendPercValues,  // Index [16]
    @AC_SendInserts,  // Index [17]
    @AC_SendPHRprgm,  // Index [18]
    @AC_PhasingRotorToFPGA,  // Index [19]
    @AC_SendLeslieLiveParams,  // Index [20]
    @AC_SendRotarySpeed,  // Index [21]
    @AC_SendGM2ena,  // Index [22]
    @AC_SendGMlowerLvl,  // Index [23]
    @AC_SendGMpedalLvl,  // Index [24]
    @AC_SendGMupperLvl,  // Index [25]
    @AC_SendGMvoiceLower0,  // Index [26]
    @AC_SendGMvoiceLower1,  // Index [27]
    @AC_SendGMvoicePedal0,  // Index [28]
    @AC_SendGMvoicePedal1,  // Index [29]
    @AC_SendGMvoiceUpper0,  // Index [30]
    @AC_SendGMvoiceUpper1,  // Index [31]
    @AC_SendMIDIccSet,  // Index [32]
    @AC_SplitConfigToFPGA,  // Index [33]
    @AC_VibratoToFPGA,  // Index [34]
    @AC_SendReverb,  // Index [35]
    @AC_SetDetent,  // Index [36]
    @AC_SendTrimPots,  // Index [37]
    @AC_SendVolumes,  // Index [38]
    @AC_SendUpperDBs,  // Index [39]
    @AC_SendLowerDBs,  // Index [40]
    @AC_SendConvertedPedalDBs,  // Index [41]
    @AC_SendPedalDBs,  // Index [42]
    @AC_SendMasterVolume,  // Index [43]
    @AC_SetLEDdimmer,  // Index [44]
    @AC_RouteDirect,  // Index [45]
    nil   // Index [46]
  );


var
  idx, temp_w: Word;
  temp_b: Byte;
  ac_mb_inc, ac_mb_dec: Boolean;
  ac_mb_v1, ac_mb_v2: Boolean;
  ac_proclist_flags: Array[0..c_proc_max] of Byte;

  ac_swell_integrator_w, ac_volume_integrator_w: Word;
  ac_swell_w, ac_volume_w: Word;
  ac_swell_w_old, ac_volume_w_old: Word;


// #############################################################################
// ###                         MESSAGE SENDER                                ###
// #############################################################################

procedure AC_sendmsg(edit_idx, event_source: Word);
// Event-Sender: Sorgt dafür, dass Änderungen nicht an den Absender zurückgehen
// edit_idx muss zwischen 0 und 511 liegen!
var new_val, param: Word;
  my_menu_requ: Byte;
begin
  if edit_idx > (c_common_preset_len - 1) then
    exit;
  new_val:= edit_array[edit_idx];
  param:= edit_idx + 1000;
  my_menu_requ:= EditIdx2MenuInverseArray[edit_idx];
{$IFDEF USE_EVETFT}
  if (event_source <> c_gui_event_source) then
    EveUpdateGUIelement(edit_idx, new_val);
{$ENDIF}
  case event_source of
  // c_to_fpga_event_source: nur ans FPGA, interne Änderung
  // c_midi_sysex_source: SysEx-Events kommen immer vom Editor
  c_editor_event_source: // Durch Editor oder TouchOSC verursachte Events
    if ConnectMode = c_connect_osc_wifi then begin
      NB_SendBinaryVal(param, new_val); // OSC braucht das Event zurück
      mDelay(5);
    end;
  c_board_event_source, c_preset_event_source, c_control_event_source,
  c_menu_event_source, c_gui_event_source: // Durch Bedienung verursachte Events
      case ConnectMode of
      c_connect_midi, c_connect_editor_midi: // speziell für XB3-Einbau und Hammond-CC-Set
        begin
          if edit_MIDI_CC_Set = 1 then begin
            if ValueInRange(edit_idx, 0, 8) then begin
              temp_b:= lo(edit_idx);
              new_val:= (temp_b * 9) + (new_val div 15);   // Hammond-DBs
              edit_idx:= 208;
            end else if ValueInRange(edit_idx, 16, 24) then begin
              temp_b:= lo(edit_idx) - 16;
              new_val:= (temp_b * 9) + (new_val div 15);
              edit_idx:= 209;
            end else if edit_idx = 264 then begin
              temp_b:= (edit_VibKnob div 2) * $20 + $20;
              edit_idx:= 211;
              MIDI_SendIndexedController(edit_idx, temp_b);
              if edit_VibKnob.B0 then
                new_val:= 127
              else
                new_val:= 0;
              edit_idx:= 215;
            end;
          end;
          MIDI_SendIndexedController(edit_idx, new_val);
          if ConnectMode = c_connect_editor_midi then
            MIDI_SendSysExParam(param, Integer(new_val));
        end;
      c_connect_osc_midi: //
        MIDI_SendIndexedController(edit_idx, new_val);
      c_connect_osc_wifi: //
        OSC_SendBinaryVal(param, new_val);
      c_connect_editor_serial: //
        begin
          NB_SendBinaryVal(param, new_val);
          MIDI_SendIndexedController(edit_idx, new_val);
        end;
      end;
  c_midi_event_source: //
    // über MIDI-CCs verursachte Events an Editor weitergeben
    case ConnectMode of
      c_connect_editor_midi: //
        MIDI_SendSysExParam(param, new_val);
      c_connect_editor_serial, c_connect_osc_wifi: //
        NB_SendBinaryVal(param, new_val)
    else
      MenuIndex_SplashIfEnabled:= my_menu_requ;
    end;
  end;
end;

// #############################################################################
// ###      Wrapper für Highlevel-Funktionen, die Argumente benötigen        ###
// #############################################################################

procedure AC_SendPHRprgm;
var my_phrset: Word;
begin
{$IFDEF DEBUG_AC}
  Serial1_sendstringCRLF('/ AC Load Phasing and send to FPGA');
{$ENDIF}
  if edit_LogicalTab_PHR_Celeste and edit_LogicalTab_PHR_Ensemble then
    my_phrset:= 6 // Vibrato 1, dünn
  else if edit_LogicalTab_PHR_Celeste and edit_LogicalTab_PHR_Fading then
    my_phrset:= 7 // Vibrato 2, X66 etwas langsamer
  else if edit_LogicalTab_PHR_WersiBoehm then
    my_phrset:= 2
  else if edit_LogicalTab_PHR_Ensemble then
    my_phrset:= 3
  else if edit_LogicalTab_PHR_Celeste then
    my_phrset:= 4
  else if edit_LogicalTab_PHR_Fading then
    my_phrset:= 5
  else
    my_phrset:= 0;  // Keine Funktion an, WersiVoice!
  NB_LoadPhasingSet(my_phrset);
  FH_PhasingRotorToFPGA;
end;

// Wrapper für Proc-Tabelle:
procedure AC_OrganParamsToFPGA;  // Index [37]
begin
  FH_OrganParamsToFPGA;
end;

procedure AC_PhasingRotorToFPGA;  // Index [38]
begin
  FH_PhasingRotorToFPGA;
end;

procedure AC_SplitConfigToFPGA;  // Index [40]
begin
  FH_SplitConfigToFPGA;
end;

procedure AC_WaveBlocksToFPGA;  // Index [42]
begin
  FH_WaveBlocksToFPGA;
end;

// -----------------------------------------------------------------------------

procedure AC_SendUpperDBs;
begin
  FH_UpperDrawbarsToFPGA;
end;

procedure AC_SendLowerDBs;
begin
  FH_LowerDrawbarsToFPGA;
end;

procedure AC_SendPedalDBs;
begin
  FH_PedalDrawbarsToFPGA;
end;

// -----------------------------------------------------------------------------

procedure ac_convert_pedal2;
// 2 Hammond B3-Drawbars auf 12 umsetzen
begin
  for idx:= 0 to 11 do begin
    temp_w:= (edit_PedalDB_B3_16 * eep_PedalDBfacs[0][idx]) div 127;
    edit_PedalDBs[idx]:= lo(temp_w);
  end;
  for idx:= 2 to 11 do begin
    temp_w:= edit_PedalDBs[idx]
           + (edit_PedalDB_B3_8 * eep_PedalDBfacs[2][idx]) div 127;
    if temp_w > 127 then
      temp_w:= 127;
    edit_PedalDBs[idx]:= lo(temp_w);
  end;
end;

procedure ac_convert_pedal4;
// 4 Hammond H100-Drawbars auf 12 umsetzen
begin
  for idx:= 0 to 11 do begin
    temp_w:= ((edit_PedalDB_B3_16 * eep_PedalDBfacs[0][idx]) div 127)
           + ((edit_PedalDB_B3_16H * eep_PedalDBfacs[1][idx]) div 127);
    if temp_w > 127 then
      temp_w:= 127;
    edit_PedalDBs[idx]:= lo(temp_w);
  end;
  for idx:= 2 to 11 do begin
    temp_w:=((edit_PedalDB_B3_8 * eep_PedalDBfacs[2][idx]) div 127)
          + ((edit_PedalDB_B3_8H * eep_PedalDBfacs[3][idx]) div 127);
    if temp_w > 127 then
      temp_w:= 127;
    temp_w:= edit_PedalDBs[idx] + temp_w;
    if temp_w > 127 then
      temp_w:= 127;
    edit_PedalDBs[idx]:= lo(temp_w);
  end;
end;

procedure AC_SendConvertedPedalDBs;
begin
  if edit_PedalDBsetup >= 2 then
    exit;
  if edit_PedalDBsetup = 0 then
    ac_convert_pedal2
  else // muss 1 sein
    ac_convert_pedal4;
  AC_SendPedalDBs;
  if ConnectMode = c_connect_editor_serial then
    // DB-Änderungen sofort als Block senden
    NB_SendEditArrayBlock(c_PedalDBs, 12)
  else
    for idx:= c_PedalDB_16 to c_PedalDB_mixt3 do
      AC_sendmsg(idx, c_control_event_source);
end;

// -----------------------------------------------------------------------------

procedure AC_SendTaper;
begin
{$IFDEF DEBUG_AC}
  Serial1_sendstringCRLF('/ AC Tapering to FPGA');
{$ENDIF}
  FH_KeymapToFPGA(edit_TG_size, edit_HighFoldbackOn);
  FH_TaperingToFPGA(edit_TG_TaperCaps);
  FH_NoteHighpassFilterToFPGA(edit_TG_size, edit_TG_FilterFac);
end;

procedure AC_RouteDirect;
// TODO: Percussion
begin
  //FH_UpperRoutingToFPGA(word_array);       // TODO: Array-Übergabe
  FH_PercussionParamsToFPGA; // Perc-Bits könnten sich geändert haben
  FH_UpperDrawbarsToFPGA;
  FH_LowerDrawbarsToFPGA;
end;


procedure AC_SendTuningVals;
begin
  FH_TuningValsToFPGA(edit_TG_TuningSet);
end;

procedure AC_SendInserts;
begin
  FH_InsertsToFPGA;
  AC_SendVolumes;
end;

procedure AC_SendGating;
begin
{$IFDEF DEBUG_AC}
  Serial1_sendstringCRLF('/ AC Gating to FPGA');
{$ENDIF}
  FH_OrganParamsToFPGA;
  AC_SendPercValues;   // auch DBs, wg. EG und Percussion
  FH_LowerDrawbarsToFPGA;
  AC_SendVolumes;  // wg. Pedal to Lower Vib
end;

// -----------------------------------------------------------------------------

procedure AC_SendRotarySpeed;
begin
  EXT_LESL_FAST:= edit_LogicalTab_LeslieFast and edit_LogicalTab_LeslieRun;
  EXT_LESL_RUN:= edit_LogicalTab_LeslieRun and (not edit_LogicalTab_LeslieFast);
  FH_SendAuxLEDs;
{
  my_bool:= edit_LogicalTab_LeslieFast and edit_LogicalTab_LeslieRun;
  VKPORT_LESFAST:= my_bool; // Leslie 11pin, vom I2C Vibrato-Knob-Port
  PREAMP_LESFAST:= my_bool; // an PL29 PREAMP CTRL
  my_bool:= edit_LogicalTab_LeslieRun and (not edit_LogicalTab_LeslieFast);
  VKPORT_LESRUN:= my_bool; // Leslie 11pin, vom I2C Vibrato-Knob-Port
  PREAMP_LESRUN:= my_bool; // an PL29 PREAMP CTRL;
} 
  MIDI_SendVent;
end;

procedure AC_SendMIDIccSet;
begin
  DF_LoadCCarray(edit_MIDI_CC_Set);   // setzt UseSustainSostMask
  NB_CreateInverseCCarrays;
  MIDI_SendSustainSostEnable;
end;

procedure AC_SetDetent;
begin
// TODO!
end;

// -----------------------------------------------------------------------------

procedure AC_SendGMprgRequestDisplay(idx: Integer; gm_prg: Byte);
// GM-Programm senden und Namen anfordern, kommt später über SysEx vom DSP
begin
{$IFDEF DEBUG_AC}
  Serial1_sendstring('/ AC SendGMprg #');
  Serial1_sendIntValCRLF(Integer(gm_prg));
{$ENDIF}
  // Programm setzen
  MIDI_SendNRPN($3550 + idx, gm_prg);
//  // Namen anfordern, wird über SysEx in GM_VoiceNames[] gesetzt
  MIDI_SendNRPN($3570 + idx, 127);
  GM_VoiceNameToDisplaySema[idx]:= GM_VoiceNameToDisplaySema[idx]
  or (ConnectMode = c_connect_osc_midi) or (ConnectMode = c_connect_osc_wifi);
end;

procedure AC_SendGM2ena;
begin
  temp_b:= (edit_LocalEnable shl 4) or edit_MIDI_Channel;
{$IFDEF DEBUG_AC}
  Serial1_sendstring('/ AC SendGMena #');
  Serial1_sendIntValCRLF(Integer(temp_b));
{$ENDIF}
  MIDI_SendNRPN($357F, temp_b); // Kanal und Freigabe für SAM5504
  AC_SendVolumes;
  ToneChanged:=true;
end;

// -----------------------------------------------------------------------------

procedure AC_SendGMvoiceUpper0;
begin
  AC_sendmsg(0224, c_control_event_source);
  AC_SendGMprgRequestDisplay(0, edit_UpperGMprg_0);
end;


procedure AC_SendGMvoiceUpper1;
begin
  AC_sendmsg(0227, c_control_event_source);
  AC_SendGMprgRequestDisplay(4, edit_UpperGMprg_1);
end;

procedure AC_SendGMupperLvl;
begin
{$IFDEF DEBUG_AC}
  Serial1_sendstringCRLF('/ AC SendGMupperLvl');
{$ENDIF}
  // layer 1:
  MIDI_SendNRPN($3530, edit_UpperGMharm_0);
  MIDI_SendNRPN($3560, edit_UpperGMlvl_0);
  // layer 2:
  if eep_BoardInfo.LicenceExtValid then begin
    MIDI_SendNRPN($3524, edit_UpperGMdetune_1 + 57);
    MIDI_SendNRPN($3534, edit_UpperGMharm_1);
    MIDI_SendNRPN($3564, edit_UpperGMlvl_1);
  end else
    MIDI_SendNRPN($3564, 0);
end;

// -----------------------------------------------------------------------------

procedure AC_SendGMvoiceLower0;
begin
  AC_SendGMprgRequestDisplay(1, edit_LowerGMprg_0);
end;

procedure AC_SendGMvoiceLower1;
begin
  AC_SendGMprgRequestDisplay(5, edit_LowerGMprg_1);
end;

procedure AC_SendGMlowerLvl;
begin
{$IFDEF DEBUG_AC}
  Serial1_sendstringCRLF('/ AC SendGMlowerLvl');
{$ENDIF}
  // layer 1:
  MIDI_SendNRPN($3531, edit_LowerGMharm_0);
  MIDI_SendNRPN($3561, edit_LowerGMlvl_0);
  // layer 2:
  if eep_BoardInfo.LicenceExtValid then begin
    MIDI_SendNRPN($3525, edit_LowerGMdetune_1 + 57);
    MIDI_SendNRPN($3535, edit_LowerGMharm_1);
    MIDI_SendNRPN($3565, edit_LowerGMlvl_1);
  end else
    MIDI_SendNRPN($3565, 0);
end;

// -----------------------------------------------------------------------------

procedure AC_SendGMvoicePedal0;
begin
  AC_SendGMprgRequestDisplay(2, edit_PedalGMprg_0);
end;

procedure AC_SendGMvoicePedal1;
begin
  AC_SendGMprgRequestDisplay(6, edit_PedalGMprg_1);
end;

procedure AC_SendGMpedalLvl;
begin
{$IFDEF DEBUG_AC}
  Serial1_sendstringCRLF('/ AC SendGMpedalLvl');
{$ENDIF}
  // layer 1:
  MIDI_SendNRPN($3532, edit_PedalGMharm_0);
  MIDI_SendNRPN($3562, edit_PedalGMlvl_0);
  // layer 2:
  if eep_BoardInfo.LicenceExtValid then begin
    MIDI_SendNRPN($3526, edit_PedalGMdetune_1 + 57);
    MIDI_SendNRPN($3536, edit_PedalGMharm_1);
    MIDI_SendNRPN($3566, edit_PedalGMlvl_1);
  end else
    MIDI_SendNRPN($3566, 0);  //  edit_PedalGMlvl_1
end;

// -----------------------------------------------------------------------------

procedure AC_SetLEDdimmer;
begin
  SWI_SetLEDdimmer(edit_LED_PWM);
  // LED-PWM für MIDI-Scancore, AUX-Bits als LED-Treiber
  SPI_fpga_send_byte($0E, (edit_LED_PWM shl 4) or (edit_LocalEnable xor 7));   // ScanCore SPI Local MIDI Send Disables
  FH_SendAuxLEDs;
end;

// #############################################################################
// ###                        SWELL und VOLUMES                              ###
// #############################################################################

function ac_detent_shift(my_val, detent_shift: Byte): Word;
var diff_i, val_i: Integer;
begin
  // bei Equalizer und Percussion Volume von Mittelwert ausgehen
  // Detent-Shift-Wert aus EEPROM bzw. edit_table
  val_i:= Integer(my_val);
  diff_i:= Integer(detent_shift);
  diff_i:= diff_i - 64;
  if my_val < 64 then
    // unterhalb Mittelstellung, n < 64
    val_i:= val_i + (val_i * diff_i div 64)
  else
    // oberhalb Mittelstellung, n >= 64, läuft von 64 bis 127
    val_i:= val_i + ((127 - val_i) * diff_i div 64);
  result:= val_i;
end;

// #############################################################################
// ###                    Master Volume setzen und an DSP                    ###
// #############################################################################

procedure AC_SendMasterVolume;
// sendet GM-Volume und setzt nur neuen Zielwert ac_volume_w für Integrator
var scaled_vol: Byte;
begin
  // Integrator nach Logarithmierung!
  MIDI_SendNRPN($3510, edit_MasterVolume);   // SAM55004 GM2 General Master Volume
  scaled_vol:= muldivbyte(edit_MasterVolume, edit_GM2organVolume, 127);
  ac_volume_w:= word(c_DrawbarLogTable[scaled_vol]) * 2; // neuer Wert, 0..254
end;

// #############################################################################
// ###                  Schweller und Volume an FPGA senden                  ###
// #############################################################################

procedure AC_SendSwell;
// SCHWELLPEDAL- und MASTER-VOLUME-Steuerung
// Wird alle 2ms aus main_tasks aufgerufen wg. Integratoren
const
  // Scale * int_fac < 256, sonst Word-Überlauf!
  int_fac_swell: Word = 7;
  int_div_swell: Word = int_fac_swell + 1;
  int_shift_swell: Byte = 4;  // Scale = 16 bei 4 shifts
  int_fac_volume: Word = 15;
  int_div_volume: Word = int_fac_volume + 1;
  int_shift_volume: Byte = 3;  // Scale = 8 bei 3 shifts
  
var swell_raw255, swell_ranged,
    swell_63hz, swell_midrange,
    swell_bypass, swell_fullrange,
    swell_pedal,
    swell_final, swell_temp: Word;
    swell_changed: Boolean;
begin
  // Volume Integrator, t = 2ms
  ac_volume_integrator_w:= ((ac_volume_integrator_w * int_fac_volume)
                          + (ac_volume_w shl int_shift_volume)) div int_div_volume;
  temp_w:= ac_volume_integrator_w shr int_shift_volume;
  if temp_w <> ac_volume_w_old then begin
    ac_volume_w_old:= temp_w;
    // 72 = Master Vol, 0..1016 div 4 = 0..255
    SPI_fpga_send_Word(72, temp_w);
  end;

  if SwellPedalControlledByMIDI then
    // result:= ((oldVal * fact) + newVal) div (fact + 1);
    ac_swell_w:= word(MIDIswell128 shl 1)  // *2, 0..254
  else
    ac_swell_w:= ADC_GetSwell; // ist schon im Bereich 0..255

  // Swell Integrator, t = 2ms
  ac_swell_integrator_w:= ((ac_swell_integrator_w * int_fac_swell)
                         + (ac_swell_w shl int_shift_swell)) div int_div_swell;
  temp_w:= ac_swell_integrator_w shr int_shift_swell;
  swell_changed:= temp_w <> ac_swell_w_old;
  if swell_changed then begin
    ac_swell_w_old:= temp_w;
    if not SwellPedalControlledByMIDI then
      MIDI_NewSwellVal:= ac_swell_w_old shr 1;
  end;
  swell_raw255:= ac_swell_w_old and $00FF;

  if swell_changed or ToneChanged then begin
{$IFDEF DEBUG_AC}
    Serial1_sendstringCRLF('/ AC Swell: ' + ByteToStrTrim(swell_raw255));
{$ENDIF}

    swell_final:= 128 + edit_TrimSwell;
    case edit_PreampSwellType of
    0:
      begin
        // Hammond Mode, ausgeprägtes, aber flaches Maximum bei 200 Hz,
        // ab 250 Hz mit 3-4 db/Okt fallend, über 4 kHz stärker
        // TONE-Pot, Minimal Swell und Swell Trim Cap werden berücksichtigt
        // Range auf Minimal Swell anpassen
        swell_ranged:= edit_MinimalSwell + MulDivByte(swell_raw255, 255-edit_MinimalSwell, 255);

        swell_temp:= MulDivByte(edit_TonePot, swell_ranged, 200);
        swell_fullrange:= (swell_ranged div 4) + swell_temp; // 0..63
        swell_temp:= MulDivByte(swell_ranged, 175, 255);
        swell_63hz:= 80 + swell_temp; //
        swell_midrange:= swell_ranged;
        // Finales Lowpass-Filter 6db/Okt.
        // Frequenzen ermittelt mit IIR_Filter_Coef_Generator.xls
        // Bit 7 = 0, Hammond Mode, 4khz-Bereich um 12 dB abgesenkt
        // Frequenz 120,3 Hz * (Wert + 1) nom. 40 für 4800 Hz
        swell_temp:= (edit_TonePot div 3) + 10;
        SPI_fpga_send_byte(87, swell_temp);  // 0..42, ca. 4,5 kHz Grenzfrequenz

        // Filter Bypass, full range ohne Tone-Lowpass
        swell_bypass:= 0;
        swell_pedal:= 35 + MulDivByte(swell_ranged, 220, 255);
      end;
    1:  
      begin // Conn, Böhm etc. Sinus
        swell_63hz:= MulDivByte(swell_raw255, 150, 255);
        swell_midrange:= MulDivByte(swell_raw255, 165, 255);
        swell_bypass:= MulDivByte(swell_raw255, 120, 255); // - 12 dB in Preamp
        // in AO28-Sim ist dieser Pegel nur um -6 dB abgesenkt, wenn Linear Mode ON
        swell_fullrange:= MulDivByte(swell_raw255, 140, 255); // - 6 dB in Preamp
        // Finales Lowpass-Filter 6db/Okt.
        SPI_fpga_send_byte(87, 45);  // ca. 5,5 kHz Grenzfrequenz
        swell_pedal:=  swell_raw255;
      end;
    2:
      begin // andere, fast linear, etwas Bass-Anhebung
        swell_63hz:= 40;
        swell_midrange:= MulDivByte(swell_raw255, 95, 255);
        swell_bypass:= MulDivByte(swell_raw255, 145, 255); // - 12 dB in Preamp
        // in AO28-Sim ist dieser Pegel nur um -6 dB abgesenkt, wenn Linear Mode ON
        swell_fullrange:= MulDivByte(swell_raw255, 190, 255); // - 6 dB in Preamp

        // Finales Lowpass-Filter 6db/Okt.
        // Frequenzen ermittelt mit IIR_Filter_Coef_Generator.xls
        // Bit 7 = 1, 4khz-Bereich nur um 6 dB abgesenkt
        // Frequenz 120,3 Hz * (Wert + 1) + 128 für 4k Enhanced
        SPI_fpga_send_byte(87, 128 + 47);  // ca. 6 kHz Grenzfrequenz
        swell_pedal:= swell_raw255;
      end;
    end;

    if edit_EnablePedalAudio then begin
      // Pedal-Signal für separaten Ausgang auf Extension Board und Postmix:
      if edit_LogicalTab_PedalPostMix              // Pedal Bypass Tab
      or (edit_ConfBits2.B6 and edit_LogicalTab_RotarySpkrBypass) then begin
        // bei Pedal Bypass wird direkt auf Ausgang gemischt
        SPI_fpga_send_byte(45, 0);  // Pedal to Lower Vib
        SPI_fpga_send_byte(46, 0);  // Pedal to AO28
      end else begin
        // normales Pedal Routing mit oder ohne Lower Vibrato
        if edit_ConfBits1.B4 and (edit_GatingKnob = 0) then begin
          // Pedal an Vibrato Lower, über AO28
          SPI_fpga_send_scaled_byte(45, edit_PedalVolume, 160);  // Pedal an Lower Vib
          SPI_fpga_send_byte(46, 0); // nichts an AO28
        end else begin
          // Pedal Dry über AO28
          SPI_fpga_send_byte(45, 0); // nichts an Lower Vib
          SPI_fpga_send_scaled_byte(46, edit_PedalVolume, 180);  // Pedal an AO28
        end;
      end;
      if edit_ConfBits1.B6 then begin
        // Swell disable für separaten Ausgang auf Extension Board und Postmix
        swell_pedal:= mulDivByte(edit_PedalVolume, 150, 100) // 0..191
                         + (swell_pedal div 4); // geringer Anteil Swell
      end;
      SPI_fpga_send_byte(47, swell_pedal); // Pedal to Ext. Output & Postmix
    end else begin
      SPI_fpga_send_byte(45, 0);
      SPI_fpga_send_byte(46, 0);
      SPI_fpga_send_byte(47, 0);
    end;

    SPI_fpga_send_byte(80, swell_63hz);
    SPI_fpga_send_byte(81, swell_midrange);
    SPI_fpga_send_byte(82, swell_bypass);
    SPI_fpga_send_byte(83, swell_fullrange);
    SPI_fpga_send_byte(84, swell_final);      // final AO28 gain

    ToneChanged:= false;
  end;
end;


procedure AC_SendTrimPots;
var temp_vol: Byte;
begin
{$IFDEF DEBUG_AC}
  Serial1_sendstringCRLF('/ AC Trimpots to FPGA');
{$ENDIF}
  // DREAM FX5000 Biquads
  // Mid ist immer Typ 1 = parametrisch Peak
  // bei Änderungen wird EQ in SAM-FW neu initialisiert
  MIDI_SendNRPN($351D, byte(edit_EqualizerFullParametric)); // SAM5504 EQU Bass/Treble Type

  temp_vol:= ac_detent_shift(edit_EqualizerBass, edit_EquBassDetentShift);
  MIDI_SendNRPN($3514, temp_vol);      // SAM5504 EQU 1
  // Bass EQ 0 = 32 Hz, 64 = 544 Hz, 127 = 2048 Hz
  MIDI_SendNRPN($3515, edit_EqualizerBassFreq);  // SAM5504 Bass EQU Mittenfrequenz

  temp_vol:= ac_detent_shift(edit_EqualizerMid, edit_EquMidDetentShift);
  MIDI_SendNRPN($3517, temp_vol);       // SAM5504 EQU 2
  // Mid EQ 0= 127 Hz, 64=1150 Hz, 127=4200 Hz
  MIDI_SendNRPN($3518, edit_EqualizerMidFreq);   // SAM5504 Mid EQU Mittenfrequenz
  MIDI_SendNRPN($3519, edit_EqualizerMidPeak div 2);   // SAM5504 Mid EQU Damp/Q

  temp_vol:= ac_detent_shift(edit_EqualizerTreble, edit_EquTrebleDetentShift);
  MIDI_SendNRPN($351A, temp_vol);      // SAM5504 EQU 3
  // Treble EQ 0 = 500 Hz, 64 = 2550 Hz, 127 = 8500 Hz
  MIDI_SendNRPN($351B, edit_EqualizerTrebleFreq);  // SAM5504 Treble EQU Mittenfrequenz

  if edit_EqualizerFullParametric then begin
    MIDI_SendNRPN($3516, edit_EqualizerBassPeak div 2);  // SAM5504 Bass EQU Damp/Q
    MIDI_SendNRPN($351C, edit_EqualizerTreblePeak div 2);  // SAM5504 Treble EQU Damp/Q
  end;
  FH_TubeCurveToFPGA(edit_TubeAmpCurveA, edit_TubeAmpCurveB);
end;


procedure AC_SendLeslieLiveParams;
var my_val, my_spread_angle: Byte;
  val_w: Word;
// wird bei Änderungen aufgerufen
begin
  SPI_fpga_send_byte(180, eep_LeslieInits[c_LeslieInpLvl]); // Leslie Input Level
{$IFDEF DEBUG_AC}
  Serial1_sendstringCRLF('/ AC LeslieLiveParams');
{$ENDIF}
  my_val:= eep_LeslieInits[11];
  SPI_fpga_send_byte(187, my_val); // Crossmix 40..157
  my_spread_angle:= (edit_LeslieSpread shr 1) + 40;
  my_val:= eep_LeslieInits[48] + my_spread_angle;  // +0..127  MAIN
  eep_LeslieInits[49]:= my_val;
  SPI_fpga_send_byte(225, my_val);
  my_val:= eep_LeslieInits[50] + my_spread_angle;  // +0..127  NEAR
  eep_LeslieInits[51]:= my_val;
  SPI_fpga_send_byte(227, my_val);
  my_val:= eep_LeslieInits[52] + my_spread_angle;  // +0..127  FAR
  eep_LeslieInits[53]:= my_val;
  SPI_fpga_send_byte(229, my_val);
  my_val:= eep_LeslieInits[54] + my_spread_angle;  // +0..127  THROB
  eep_LeslieInits[55]:= my_val;
  SPI_fpga_send_byte(231, my_val);

  // Rotor/Horn Balance einstellen - entgegengesetzten Wert absenken
  if edit_LeslieBalance >= 64 then begin
    // Rotor-Pegel reduzieren
    my_val:= MulDivByte(eep_LeslieInits[6], (128-edit_LeslieBalance), 64);
    SPI_fpga_send_byte(182, my_val);   // skalierter Rotor-Anteil

    // Hornpegel konstant, unabhängig von Balance
    SPI_fpga_send_byte(181, eep_LeslieInits[5]);
  end else begin
    // Horn-Pegel reduzieren
    my_val:= MulDivByte(eep_LeslieInits[5], edit_LeslieBalance, 64);
    SPI_fpga_send_byte(181, my_val);

    // Rotorpegel konstant, unabhängig von Balance
    SPI_fpga_send_byte(182, eep_LeslieInits[6]);
  end;
  
  // Throb-Berechnung - durch Quadrierung benötigt Throb-Wave-Mod einen "Bias"
  val_w:= Word(c_AntiLogTable[edit_LeslieThrob]) + 128;
  // Horn-Throb
  temp_w:= (Word(eep_LeslieInits[22]) * val_w) div 255;   // Throb Horn
  SPI_fpga_send_byte(198, lo(temp_w));  // 0..254 auf Horn L
  SPI_fpga_send_byte(199, lo(temp_w));  // 0..254 auf Horn R
  // Rotor-Throb
  val_w:= val_w + 30;
  temp_w:= (Word(eep_LeslieInits[27]) * val_w) div 255;   // Throb Rotor
  if temp_w > 255 then
    temp_w:= 255;
  SPI_fpga_send_byte(203, lo(temp_w));  // Rotor L
  SPI_fpga_send_byte(204, lo(temp_w));  // Rotor R
end;


// #############################################################################

procedure AC_SendVolumes;
// UPPER/LOWER/PEDAL Volumes
// wird bei Änderungen aufgerufen
// Rechnet Byte "volume" in EQ-Paramater um
begin
{$IFDEF DEBUG_AC}
  Serial1_sendstringCRLF('/ AC Volumes');
{$ENDIF}
  SPI_fpga_send_byte(180, eep_LeslieInits[c_LeslieInpLvl]); // Leslie Input Level
  
  if edit_LogicalTab_TubeAmpBypass then
    SPI_fpga_send_byte(70, 0)    // Amp Out Level
  else begin
    // Amp122 auf 35..127 begrenzen
    temp_w:= muldivbyte(edit_LeslieVolume, 100, 127) + 27; // 35..127
    // NEU ab FPGA 01032022
    SPI_fpga_send_volume_byte(69, lo(temp_w)); // Amp In Gain in Volume-Gruppe, auf 0..255
    
    if edit_ConfBits1.2 then // Volume Correction bit gesetzt?
      // für Amp Out Lvl
      temp_w:= 240 - (ValueTrimLimit(edit_LeslieVolume, 0, 33) * 4)
              - (edit_LeslieVolume div 5)
    else
      // nur geringe Korrektur für Leslie-Sim
      temp_w:= 230 - (edit_LeslieVolume div 3);

    SPI_fpga_send_byte(70, lo(temp_w));    // Amp Out Level, in Volume-Gruppe, auf 0..255
  end;

  temp_w:= muldivbyte(edit_MasterVolume, edit_GM2organVolume, 127);
  SPI_fpga_send_volume_byte(72, lo(temp_w));     // 72 = Master Vol NEU ab FPGA 17112020

  temp_w:= (Word(edit_GM2synthVolume) shr 2) + 96;
  MIDI_SendNRPN($3509, temp_w); // SAM55004 GM2 Pre-Mix Gain
  MIDI_SendNRPN($3512, 127);                 // SAM55004 GM2 Master Volume

  temp_w:= ac_detent_shift(edit_UpperVolumeDry, edit_PercVolDetentShift);
  
  if edit_EnableUpperAudio then begin
    SPI_fpga_send_scaled_byte(34, edit_UpperVolumeWet, 150);   // 34 = Upper Manual Vol auf 0..200
    SPI_fpga_send_scaled_byte(37, temp_w, 150);   // 37 = Perc/lvl_2nd_voice Vol auf 0..200
  end else begin
    SPI_fpga_send_byte(34, 0);   // 34 = Upper Manual Vol auf 0
    SPI_fpga_send_byte(37, 0);   // 37 = Perc/lvl_2nd_voice Vol auf 0
  end;
  
  if edit_EnableLowerAudio then
    SPI_fpga_send_scaled_byte(35, edit_LowerVolume, 150)  // 35 = Lower Manual Vol auf 0..200
  else
    SPI_fpga_send_byte(35, 0);   // 35 = Lower Manual Vol auf 0

  // LED-PWM für MIDI-Scancore, AUX-Bits als LED-Treiber
  SPI_fpga_send_byte($0E, (edit_LED_PWM shl 4) or (edit_LocalEnable xor 7));   // ScanCore SPI Local MIDI Send Disables
  if edit_PreampSwellType = 0 then // Hammond, mit TRIODE K2 AGE-Pot
    SPI_fpga_send_byte(85, 255 - edit_Triode_k2)  // 85 = TRIODE_K2  255..155
  else
    SPI_fpga_send_byte(85, 255);  // Triode k2

  ToneChanged:= true;  // sende SWELL
end;


// #############################################################################
// ###                      VOICE/PRESET  L O A D                            ###
// #############################################################################

procedure AC_HandleVoiceChangeUpper;
begin
  MenuRefresh:= true;
  // wurde vorab erledigt
end;

procedure AC_HandleVoiceChangeLower;
begin
  MenuRefresh:= true;
  // wurde vorab erledigt
end;

procedure AC_HandleVoiceChangePedal;
begin
  MenuRefresh:= true;
  // wurde vorab erledigt
end;

procedure ac_reset_specialbtns;
begin
  FillBlock(@edit_LogicalTab_IncDecBtns, 16, 0);   // incl. folgende Vib-Buttons
  FillEventSource(c_LogicalTab_IncDecBtns, 32, 0); // und SingleDB-Buttons
  FillEventSource(c_voices, 4, 0);
  NB_VibknobToVCbits;
  edit_array[c_LogicalTab_SingleDBtoUpper + SingleDBsetSelect]:= true;
end;

procedure AC_PresetChangeEvent(event_source: Word);
const
  s_label_preset = '/label_preset="';
begin
  AC_sendmsg(c_CommonPreset, event_source);
  MenuIndex_Splash:= c_MenuCommonPreset; // kurz neues Menü anfordern
  if (edit_CommonPreset = 0) then begin
    // Live-Einstellung. Vorherige Werte Laden
    if (edit_CommonPreset_old > 0) then
      SR_PresetTempToLive; // vorherige Werte nehmen
    NB_VibknobToVCbits;
    if edit_ADCconfig >= 2 then begin
      AC_VoiceChangeUpperEvent(event_source);  // ggf. auch zum Einlesen der Live-Drawbars
      AC_VoiceChangeLowerEvent(event_source);
      AC_VoiceChangePedalEvent(event_source);
      ADC_SetActiveAll(true);
    end;
    SWI_ForceSwitchReload;       // Schalter-Eingänge neu einlesen
    PresetInvalids[1]:= false;   // kein Blinken der Preset-LEDs
    PresetInvalids[2]:= false;
    PresetInvalids[3]:= false;
    CurrentPresetName:= s_PresetNameStr0;

  end else begin
    // Common Preset laden
    if (edit_CommonPreset_old = 0) then begin
      SWI_ForceSwitchReload;       // Schalter-Eingänge neu einlesen
      SR_PresetLiveToTemp;  // Live-Einstellung merken
    end;
    // hole edit_CommonPreset, Voice-Nummern bleiben
    SR_LoadCommonPreset(edit_CommonPreset);
    NB_VibknobToVCbits;
    PresetInvalids[1]:= true;  // Blinken der Preset-LEDs, invalid
    PresetInvalids[2]:= true;
    PresetInvalids[3]:= true;
    if (edit_ADCconfig > 1) then begin
      // Drawbars neu einlesen und annulieren
{$IFNDEF ALLINONE_37}
      ADC_ReadAll_24;
{$ENDIF}
      ADC_ReadAll_64;
      ADC_SetActiveAll(false);
    end;
    ac_reset_specialbtns;
  end;
  PresetInvalids[0]:= false;
  event_array[c_PercKnob]:= 0; // wird sonst evt. zurückübersetzt!
  edit_CommonPreset_old:= edit_CommonPreset;
  
  // temporär umkopieren in unbenutzten Bereich (IncDec-Buttons)
  CString_to_PStringArr(CurrentPresetName,  @edit_array + c_PresetNameStrArr);
  if ConnectMode = c_connect_editor_serial then  // DB-Änderungen sofort als Block senden
    NB_SendEditArrayBlock(c_PresetNameStrArr, 16)
  else if ConnectMode = c_connect_osc_wifi then begin // OSC-String
    Serial2_CRLF;
    Serial2_sendstring(s_label_preset);
    Serial2_sendstring(CurrentPresetName);  // gewandelter String
    Serial2_sendChar('"');
    Serial2_CRLF;
  end else if ConnectMode = c_connect_editor_midi then
    MIDI_SendSysEx_ParamVals(1000 + c_PresetNameStrArr, 16, false)  // originaler Pascal-String
  else
    Serial1_sendstringCRLF('/ AC Loaded ' + CurrentPresetName);
  // temporären Block wieder löschen (IncDec-Buttons)
  FillBlock(@edit_PresetNameStrTemp, 16, 0);
  NB_VibknobToVCbits;
  MenuRefresh:= true;
end;

// ------------------------------VOICE LOAD-------------------------------------

procedure AC_VoiceChangeUpperEvent(event_source: Word);
var was_live: Boolean; i: Word;
begin
  // Voice Change Upper Manual
  AC_sendmsg(c_UpperVoice, event_source);
  MenuIndex_Splash:= c_MenuCommonPreset + 1; // kurz neues Menü anfordern
  SWI_CancelActive_upr:= false; // kein Cancel mehr
  SR_CheckForLive;
  if (edit_ADCconfig >= 2) then begin
    // neue Umschalt-Logik in ADC_ChangesToEdit
    if SWI_CancelActive_upr then begin
      mDelay(8);
{$IFNDEF ALLINONE_37}
      ADC_ReadAll_24;  // aktuellen Zustand einlesen
{$ENDIF}
      ADC_ReadAll_64;
      ADC_SetActiveUpper(false);    // ADC-Kanäle unempfindlich machen (abgelaufen!)
    end else begin
      if UpperIsLive then begin
        ADC_SetActiveUpper(true);  // Force ADC Update
        ADC_ReadAndChangesToEdit;
      end else begin
        if (edit_ADCconfig = 2) then begin
          // wg. Umschaltung alte Preset12-MPX-Platine oder MAG
          mDelay(8);
{$IFNDEF ALLINONE_37}
          ADC_ReadAll_24;  // umgeschalteten Zustand einlesen
{$ENDIF}
          ADC_SetActiveLower(false);  // wg. MAG
        end;
        // ADC-Kanäle unempfindlich machen (abgelaufen!)
        ADC_SetActiveUpper(false);
        SR_LoadUpperVoice(edit_UpperVoice);
      end;
    end;
  end else begin// Expander, keine Analogeingänge
    was_live:= (edit_UpperVoice_old = 0);
    if (UpperIsLive = false) then begin
      if was_live then
        SR_UpperLiveToTemp;  // war Live, ist jetzt Preset
      SR_LoadUpperVoice(edit_UpperVoice);
    end else if (was_live = false) then
      SR_UpperTempToLive;    // war Preset, ist jetzt Live
  end;
  FH_RouteOrgan;  // wg. Percussion-Freigabe
  MIDI_SendProgramChange(0, edit_UpperVoice);
  if ConnectMode = c_connect_editor_serial then  // DB-Änderungen sofort als Block senden
    NB_SendEditArrayBlock(c_UpperDBs, 12)
  else if ConnectMode = c_connect_editor_midi then
    MIDI_SendSysEx_ParamVals(1000, 12, false)
  else
    for i:= 0 to 11 do
      AC_sendmsg(i, c_preset_event_source);
  edit_UpperVoice_old:= edit_UpperVoice;
  PresetInvalids[1]:= false;  // Upper
  PresetInvalids[0]:= true;   // Common
  MIDI_DisablePercussion:= false;
  MIDI_OverrideCancelDB1:= false;
  FH_UpperDrawbarsToFPGA;
  event_array[c_UpperVoice]:= 0;
  FillEventSource(c_UpperDBs, 12, 0);
  MenuRefresh:= true;
end;

// -----------------------------------------------------------------------------

procedure AC_VoiceChangeLowerEvent(event_source: Word);
var was_live: Boolean; i: Word;
begin
  // Voice Change Lower Manual
  AC_sendmsg(c_LowerVoice, event_source);
  MenuIndex_Splash:= c_MenuCommonPreset + 2; // kurz neues Menü anfordern
  SWI_CancelActive_Lwr:= false; // kein Cancel mehr
  SR_CheckForLive;
  if (edit_ADCconfig >= 2) then begin
    // neue Umschalt-Logik in ADC_ChangesToEdit
    if SWI_CancelActive_lwr then begin
      mDelay(8);
{$IFNDEF ALLINONE_37}
      ADC_ReadAll_24;  // aktuellen Zustand einlesen
{$ENDIF}
      ADC_ReadAll_64;
      ADC_SetActiveLower(false);    // ADC-Kanäle unempfindlich machen (abgelaufen!)
    end else begin
      if LowerIsLive then begin
        ADC_SetActiveLower(true);  // Force ADC Update
        ADC_ReadAndChangesToEdit;
      end else begin
        if (edit_ADCconfig = 2) then begin
          // wg. Umschaltung alte Preset12-MPX-Platine oder MAG
          mDelay(8);
{$IFNDEF ALLINONE_37}
          ADC_ReadAll_24;  // umgeschalteten Zustand einlesen
{$ENDIF}
          ADC_SetActiveUpper(false);  // wg. MAG
        end;
        // ADC-Kanäle unempfindlich machen (abgelaufen!)
        ADC_SetActiveLower(false);
        SR_LoadLowerVoice(edit_LowerVoice);
      end;
    end;
  end else begin // Expander, keine Analogeingänge
    was_live:= (edit_LowerVoice_old = 0);
    if (LowerIsLive = false) then begin
      if was_live then
        SR_LowerLiveToTemp;  // war Live, ist jetzt Preset
      SR_LoadLowerVoice(edit_LowerVoice);
    end else if (was_live = false) then
      SR_LowerTempToLive;    // war Preset, ist jetzt Live
  end;
  FH_RouteOrgan;  // wg. Percussion-Freigabe
  MIDI_SendProgramChange(1, edit_LowerVoice);
  if ConnectMode = c_connect_editor_serial then
    // DB-Änderungen sofort als Block senden
    NB_SendEditArrayBlock(c_LowerDBs, 12)
  else if ConnectMode = c_connect_editor_midi then
    MIDI_SendSysEx_ParamVals(1016, 12, false)
  else
    for i:= 16 to 27 do
      AC_sendmsg(i, c_preset_event_source);
  edit_LowerVoice_old:= edit_LowerVoice;
  PresetInvalids[2]:= false;  // Lower
  FH_LowerDrawbarsToFPGA;
  event_array[c_LowerVoice]:= 0;
  FillEventSource(c_LowerDBs, 12, 0);
  MenuRefresh:= true;
end;

// -----------------------------------------------------------------------------

procedure AC_VoiceChangePedalEvent(event_source: Word);
var was_live, is_live: Boolean; i: Word;
begin
  // Voice Change Pedal
  AC_sendmsg(c_PedalVoice, event_source);
  MenuIndex_Splash:= c_MenuCommonPreset + 3; // neues Menü anfordern
  is_live:= (edit_PedalVoice = 0);
  if (edit_ADCconfig >= 2) then begin
    // neue Umschalt-Logik in ADC_ChangesToEdit
    if is_live then begin
      ADC_SetActivePedal(true);  // Force ADC Update
      ADC_ReadAndChangesToEdit;
    end else begin
      ADC_SetActivePedal(false);    // ADC-Kanäle unempfindlich machen (abgelaufen!)
      SR_LoadPedalVoice(edit_PedalVoice);
    end;
  end else begin // Expander, keine Analogeingänge
    was_live:= (edit_PedalVoice_old = 0);
    if (is_live = false) then begin
      if was_live then
        SR_PedalLiveToTemp;  // war Live, ist jetzt Preset
      SR_LoadPedalVoice(edit_PedalVoice);
    end else if (was_live = false) then
      SR_PedalTempToLive;    // war Preset, ist jetzt Live
  end;
  MIDI_SendProgramChange(1, edit_PedalVoice);
  if ConnectMode = c_connect_editor_serial then begin
    // DB-Änderungen sofort als Block senden
    NB_SendEditArrayBlock(c_PedalDBs, 12);
    NB_SendEditArrayBlock(c_PedalDB4s, 4);
  end else if ConnectMode = c_connect_editor_midi then begin
    MIDI_SendSysEx_ParamVals(1032, 12, false);
    MIDI_SendSysEx_ParamVals(1072, 4, false);
  end else begin
    for i:= 32 to 43 do
      AC_sendmsg(i, c_preset_event_source);
    for i:= 72 to 75 do
      AC_sendmsg(i, c_preset_event_source);
  end;
  edit_PedalVoice_old:= edit_PedalVoice;
  PresetInvalids[3]:= false;  // Pedal
  FH_PedalDrawbarsToFPGA;
  event_array[c_PedalVoice]:= 0;
  FillEventSource(c_PedalDBs, 12, 0);
  FillEventSource(c_PedalDB4s, 4, 0);
  MenuRefresh:= true;
end;

// #############################################################################
// ####                     SPECIAL & MOMENTARY BUTTONS                      ###
// #############################################################################

procedure AC_HandleChores;
// allerlei Aufgaben, die vor Abarbeitung des Event-Arrays 
// erledigt werden müssen: Änderungen in erweiterten Parametern
// Durch Editor ausgelöste Events außerhalb event_array behandeln
var
  is_b3, any_change, is_primary_upperdb, is_not_primary_upperdb: Boolean;
  temp_val: Word;
begin
  if edit_DeviceType = 1 then // nur bei Plexi-Expander
    FH_SendAuxLEDs;
  // -------------------------EXTENDED EVENTS-----------------------------------
  // Store Events
  if ExtendedEvents[c_extevt_StoreDefaults] then
    SR_StoreDefaults;
  if ExtendedEvents[c_extevt_StoreSystemInits] then
    SR_StoreSystemInits;
  if ExtendedEvents[c_extevt_StoreExtendedParams] then
    SR_StoreExtendedParams;
  if ExtendedEvents[c_extevt_StoreCurrentOrganModel] then
    SR_StoreOrganModel(edit_OrganModel);
  if ExtendedEvents[c_extevt_StoreCurrentSpeakerModel] then
    SR_StoreOrganModel(edit_RotaryModel);
  // sonstige Events
  if ExtendedEvents[c_extevt_SendDSP] then begin
    FH_SendReverb(edit_ReverbKnob);
    AC_SendGM2ena;
  end;
  if ExtendedEvents[c_extevt_SendLeslieInits] then begin
    FH_SendLeslieInitsToFPGA;
    AC_SendLeslieLiveParams;
  end;
  if ExtendedEvents[c_extevt_DrawbarParams] then begin
    AC_SendGating;
    FH_PedalDrawbarsToFPGA;
  end;
  if ExtendedEvents[c_extevt_SendBusbarInits] then
    AC_SendTaper;
  if ExtendedEvents[c_extevt_SendPhasingInits] then
    AC_SendPHRprgm;
  if ExtendedEvents[c_extevt_AnalogRemap] then
    ADC_Init;
  if ExtendedEvents[c_extevt_ButtonRemap] then
    SWI_InitButtons;

  FillBlock(@ExtendedEvents, sizeof(ExtendedEvents), 0);

  // ----------------------------PERCUSSION-------------------------------------
  // DisablePersussion und DisableDB1 setzen
  any_change:= DisablePercussion;
  is_b3:= (edit_GatingKnob = 0) and edit_PercEnaOnLiveDBonly;
  is_primary_upperdb:= (edit_UpperVoice = 0) or (edit_CommonPreset > 0);
  is_not_primary_upperdb:= not is_primary_upperdb;
  DisablePercussion:= (is_b3 and is_not_primary_upperdb)
             or MIDI_DisablePercussion or SWI_CancelActive_upr;
  if DisablePercussion <> any_change then begin
    // erzwingt Senden von Upper und Perc über ta_perc_param
    event_array[c_PercEnaOnLiveDBonly]:= c_to_fpga_event_source;
    event_array[c_LogicalTab_PercOn]:= c_to_fpga_event_source;
  end;

  any_change:= DisableDB1;  // DisableDB1 nur bei Perc ON wirksam!
  DisableDB1:= edit_NoDB1_atPerc and is_primary_upperdb and is_b3;
  if MIDI_OverrideCancelDB1 then
    DisableDB1:= false;
  if DisableDB1 <> any_change then begin
    // erzwingt Senden von Upper und Perc über ta_perc_param
    event_array[c_PercEnaOnLiveDBonly]:= c_to_fpga_event_source;
    event_array[c_LogicalTab_PercOn]:= c_to_fpga_event_source;
  end;
  
  // -----------------------------SONSTIGE--------------------------------------
  any_change:= event_array[c_LogicalTab_LeslieFast] >= c_board_event_source;
  if any_change and edit_ConfBits2.B3 then
    NewEditIdxEvent(c_LogicalTab_PHR_Fast, edit_LogicalTab_LeslieFast, event_array[c_LogicalTab_LeslieFast]);
end;

// #############################################################################
// ####                    PRESET/VOICE/ORGANMODEL CHANGE                    ###
// #############################################################################

function AC_PresetVoiceOrganChanged: Word;
// Vor Abarbeitung des Event-Arrays zu erledigen:
// Preset/Voices/OrganModel/BoardInits laden
// Liefert TRUE, wenn ein Common Preset geladen wurde
// Load-Funktionen müssen VOR Handling der Event-Tabelle ausgeführt werden:
const
  s_label_organ = '/label_organ="';
  s_label_rotary = '/label_rotary="';
begin
  result:= 0;
  if event_array[c_CommonPreset] >= c_editor_event_source then begin
    AC_PresetChangeEvent(event_array[c_CommonPreset]);
    result:= 3;           // Änderungen senden
  end else begin
    // ansonsten ggf. Voices laden; löschen eigene VoiceChange-Events
    if event_array[c_UpperVoice] >= c_editor_event_source then
      AC_VoiceChangeUpperEvent(event_array[c_UpperVoice]);   // Lädt ggf. Drawbar-Teil neu
    if event_array[c_LowerVoice] >= c_editor_event_source then
      AC_VoiceChangeLowerEvent(event_array[c_LowerVoice]);   // Lädt ggf. Drawbar-Teil neu
    if event_array[c_PedalVoice] >= c_editor_event_source then
      AC_VoiceChangePedalEvent(event_array[c_PedalVoice]);   // Lädt ggf. Drawbar-Teil neu
    result:= 1; // Messages bereits in AC_HandleVoiceChangeXXX behandelt
  end;

  if event_array[c_OrganModel] >= c_preset_event_source then begin
    // Lädt ggf. Gating/Organ/Perc/Keybed/Vibrato neu
    if not eep_Boardinfo.LicenceExtValid then
      edit_OrganModel:= ValueTrimLimit(edit_OrganModel, 0, 3);
    SR_LoadOrganModel(edit_OrganModel);
    AC_sendmsg(c_OrganModel, c_preset_event_source);
    if ConnectMode = c_connect_osc_wifi then begin // OSC-String
      Serial2_CRLF;
      Serial2_sendstring(s_label_organ);
      Serial2_sendstring(s_OrganModelArr[edit_OrganModel]);
      Serial2_sendChar('"');
      Serial2_CRLF;
    end;
    result:= 2;  // wie bei Preset, Neueinstellungen als Message senden
    event_array[c_OrganModel]:= 0;
    MenuRefresh:= true;
  end;

  if event_array[c_RotaryModel] >= c_preset_event_source then begin
    // Lädt LeslieInits und RotaryControl neu
    if not eep_Boardinfo.LicenceExtValid then
      edit_RotaryModel:= ValueTrimLimit(edit_RotaryModel, 0, 5);
    FH_SendFIRToFPGA(edit_RotaryModel);
    SR_LoadRotaryModel(edit_RotaryModel);
    AC_sendmsg(c_RotaryModel, c_preset_event_source);
    if ConnectMode = c_connect_osc_wifi then begin // OSC-String
      Serial2_CRLF;
      Serial2_sendstring(s_label_rotary);
      Serial2_sendstring(s_SpeakerModelArr[edit_RotaryModel]);
      Serial2_sendChar('"');
      Serial2_CRLF;
    end;
    result:= 2;  // wie bei Preset, Neueinstellungen als Message senden
    event_array[c_RotaryModel]:= 0;
    MenuRefresh:= true;
  end;
  FillEventSource(c_CommonPreset, 4, 0); // alle 4 nicht neu laden
end;

// -----------------------------------------------------------------------------

procedure AC_SendPercValues;
begin
  FH_RouteOrgan;
  FH_PercussionParamsToFPGA; // Perc-Bits könnten sich geändert haben
  FH_UpperDrawbarsToFPGA;
end;

// -----------------------------------------------------------------------------


procedure AC_VibratoToFPGA;
begin
  FH_VibratoToFPGA;
end;

// -----------------------------------------------------------------------------

procedure AC_SendReverb;
begin
  FH_SendReverb(edit_ReverbKnob);
end;

procedure AC_HandleReverbKnob;
var edit_idx: Word;
begin
  // Reverb über Menü oder #1412 eingestellt?
  edit_LogicalTab_Reverb1:= edit_ReverbKnob.B0 > 0;
  edit_LogicalTab_Reverb2:= edit_ReverbKnob.B1 > 0;
  for edit_idx:= c_LogicalTab_Reverb1 to c_LogicalTab_Reverb2 do
    AC_sendmsg(edit_idx, c_control_event_source);     // zusätzlich senden
  FH_SendReverb(edit_ReverbKnob);
end;

procedure AC_HandleReverbButtons;
begin
  NB_TabsToReverbKnob;
  AC_sendmsg(c_ReverbKnob, c_control_event_source); // zusätzlich senden
  FH_SendReverb(edit_ReverbKnob);
end;

// -----------------------------------------------------------------------------

procedure AC_HandlePercKnob;
var edit_idx: Word;
begin
  // angezeigten Percussion Mode zurückübersetzen
  NB_PercKnobToTabs;
  for edit_idx:= c_LogicalTab_PercOn to c_LogicalTab_Perc3rd do
    AC_sendmsg(edit_idx, c_control_event_source);     // zusätzlich senden
  AC_SendPercValues;
end;

procedure AC_HandlePercButtons;
var event_source: Word;
begin
  // zurückübersetzen für Percussion-Menü
  NB_TabsToPercKnob;
  AC_sendmsg(c_PercKnob, c_control_event_source);
  AC_SendPercValues;
end;


// -----------------------------------------------------------------------------

procedure AC_HandleVibButtons;
begin
  // in AC_HandleMomentaryControls behandelt
end;

procedure AC_HandleVibknob;
var edit_idx: Word;
begin
  NB_VibknobToVCbits;
  for edit_idx:= c_LogicalTab_4V1 to c_LogicalTab_6C3 do
    AC_sendmsg(edit_idx, c_control_event_source);   // zusätzlich senden
  FH_VibratoToFPGA;
end;

// -----------------------------------------------------------------------------

procedure ac_send_converted_vibbtns(event_source: Word);
var edit_idx: Word;
begin
  NB_VCbitsToVibknob;
  FH_VibratoToFPGA;
  AC_sendmsg(c_VibKnob, event_source);
  for edit_idx:= c_LogicalTab_4V1 to c_LogicalTab_6C3 do
    AC_sendmsg(edit_idx, c_control_event_source);   // zusätzlich senden
  event_array[c_VibKnob]:= 0;
  MenuRefresh:= true;
end;

procedure ac_reset_vibtabs_flags;
var a_bool: Byte;
begin
  a_bool:= edit_LogicalTab_4VCh;
  FillBlock(@edit_LogicalTab_VibBtns, 6, 0);
  FillEventSource(c_LogicalTab_VibBtns, 6, 0);
  if (edit_VibKnobMode <> 3) then
    edit_LogicalTab_4VCh:= a_bool;
end;

procedure ac_incdecparam(edit_idx: Word; do_inc, do_limit: boolean; event_source: byte);
// Inc Wert in edit_array wenn do_inc TRUE, sonst Dec Wert in edit_array
var my_val: Byte;
begin
  my_val:= edit_array[edit_idx];
  if do_inc then begin
    // Increment Buttons
    if do_limit then
      IncToLimB(my_val, c_edit_max[edit_idx])
    else  // ggf. Transpose ohne Limit
      inc(my_val);
    if ac_mb_dec then  // Inc und Dec gleichzeitig
      my_val:= 0;
    ac_mb_inc:= true;
  end else begin
    // Decrement Buttons
    if do_limit then
      DectoLimB(my_val, 0)
    else  // ggf. Transpose ohne Limit, mit Überlauf
      dec(my_val);
    if ac_mb_inc then  // Inc und Dec gleichzeitig
      my_val:= 0;
    ac_mb_dec:= true;
  end;
  // Ziel-Parameter ändern
  NewEditIdxEvent(edit_idx, Word(my_val), event_source);
  MenuRefresh:= true;
end;

procedure AC_HandleNonSavedControlEvents;
// nicht gespeicherte Inc/Dec-, Vibrato und SingleDrawbar-Buttons,
// immer vorab behandeln
const
  c_pitchwheel_hyst = 12;
var
  edit_idx, edit_idx_btn, event_source: Word;
  control_type: Word;
  any_change: Boolean;
begin
  // Inc/Dec Group
  any_change:= false;
  for edit_idx_btn:= c_LogicalTab_IncDecBtns to c_LogicalTab_IncDecBtns + 15 do begin
    event_source:= event_array[edit_idx_btn];
    if (event_source > 0) then
      any_change:= true;
    if (event_source >= c_editor_event_source) then begin
      // Zielparameter aus Tabelle c_incdec2edit_idx
      edit_idx:= c_incdec2edit_idx[(edit_idx_btn - c_LogicalTab_IncDecBtns) div 2];
      // Inkrementieren wenn event_idx ungerade ist, kein Limit bei Transpose
      ac_incdecparam(edit_idx, (edit_idx_btn and 1) = 1, edit_idx <> c_GenTranspose, event_source);
      SetSystimer(c_MomentaryTimer, 75);
    end;
  end;
  if any_change then begin
    FillBlock(@edit_array + c_LogicalTab_IncDecBtns, 16, 0);
    FillBlock(@event_array + c_LogicalTab_IncDecBtns, 16, 0);
  end;
  
  // Single Drawbar Toggle, incwrap
  any_change:= false;
  for edit_idx_btn:= c_LogicalTab_SingleDBtoggle to c_LogicalTab_SingleDBtoggle + 3 do begin
    event_source:= event_array[edit_idx_btn];
    if (event_source > 0) then
      any_change:= true;
    if (event_source >= c_editor_event_source) then begin
      case edit_idx_btn of
      c_LogicalTab_SingleDBtoggle: //
        begin
          Inc(SingleDBsetSelect);
          if SingleDBsetSelect > 2 then
            SingleDBsetSelect:= 0;
        end;
      c_LogicalTab_SingleDBtoUpper: //
        SingleDBsetSelect:= 0;
      c_LogicalTab_SingleDBtoLower: //
        begin
          if SingleDBsetSelect = 1 then
            SingleDBsetSelect:= 0   // wieder ausgeschaltet
          else
            SingleDBsetSelect:= 1;
        end;
      c_LogicalTab_SingleDBtoPedal: //
        begin
          if SingleDBsetSelect = 2 then
            SingleDBsetSelect:= 0   // wieder ausgeschaltet
          else
            SingleDBsetSelect:= 2;
        end;
      end; // case
      // alle SingleDBset-Buttons löschen, nur aktiven setzen
      // c_LogicalTab_SingleDBtoggle wird in swi_get_TabLED_bits behandelt
    end; // if event_source...
  end;
  if any_change then begin
    FillBlock(@edit_array + c_LogicalTab_SingleDBdestBtns, 4, 0);
    edit_array[c_LogicalTab_SingleDBtoUpper + SingleDBsetSelect]:= 255;
  end;

  // Vibrato Buttons, setzen edit_VibKnob
  any_change:= false;
  for edit_idx_btn:= c_LogicalTab_VibBtns to c_LogicalTab_VibBtns + 5 do begin
    event_source:= event_array[edit_idx_btn];
    if (event_source > 0) then
      any_change:= true;
    if (event_source >= c_editor_event_source) then begin
      if  (edit_idx_btn = c_LogicalTab_4VCh)  // Vib/Chorus immer behandeln
      and (edit_VibKnobMode <> 3) and (edit_VibKnobMode <> 0) then
        ac_send_converted_vibbtns(event_array[c_LogicalTab_4VCh]);
      case edit_VibKnobMode of
      1:
        case edit_idx_btn of
        c_LogicalTab_4V1: //
          begin
            // 2 Binary Toggle Buttons + C/V
            // Logik: Wechselseitige Auslösung oder beide gedrückt
            edit_LogicalTab_4V1:= true;
            edit_LogicalTab_4V2:= ac_mb_v2; // nach 75 Ticks gelöscht
            ac_mb_v1:= true;
            ac_send_converted_vibbtns(event_source);
            SetSystimer(c_MomentaryTimer, 75);
            if event_source = c_control_event_source then
              MenuIndex_SplashIfEnabled:= c_ViKnobMenu;
          end;
        c_LogicalTab_4V2: //
          begin
            // 2 Binary Toggle Buttons + C/V
            // Logik: Wechselseitige Auslösung, nochmaliger Druck schaltet beide ein
            edit_LogicalTab_4V2:= true;
            edit_LogicalTab_4V1:= ac_mb_v1; // nach 75 Ticks gelöscht
            ac_mb_v2:= true;
            ac_send_converted_vibbtns(event_source);
            SetSystimer(c_MomentaryTimer, 75);
            if event_source = c_control_event_source then
              MenuIndex_SplashIfEnabled:= c_ViKnobMenu;
          end;
        c_LogicalTab_4V3: //
          edit_LogicalTab_4V3:= false;
        end;
      2:  // 4 Button Mode, V/Ch wurde oben behandelt
        if (edit_idx_btn <= c_LogicalTab_4V3) then begin
          ac_reset_vibtabs_flags;
          edit_LogicalTab_VibBtns[edit_idx_btn - c_LogicalTab_4V1]:= true;
          ac_send_converted_vibbtns(event_source);
          if event_source = c_control_event_source then
            MenuIndex_SplashIfEnabled:= c_ViKnobMenu;
        end;
      3:  // 6 Button Mode
        begin
          ac_reset_vibtabs_flags;
          edit_LogicalTab_VibBtns[edit_idx_btn - c_LogicalTab_6V1]:= true;
          ac_send_converted_vibbtns(event_source);
          if event_source = c_control_event_source then
            MenuIndex_SplashIfEnabled:= c_ViKnobMenu;
        end;
      end;
    end;
  end;
  if any_change then
    FillBlock(@event_array + c_LogicalTab_VibBtns, 6, 0);

  // Pitchwheel-MIDI Events
  any_change:= false;
  for edit_idx_btn:= c_Wheels to c_Wheels + 3 do begin
    event_source:= event_array[edit_idx_btn];
    if (event_source > 0) then
      any_change:= true;
    if (event_source >= c_editor_event_source) then begin
      case edit_idx_btn of
      c_Wheel_PitchToMIDI: // eigener Pitchwheel-Event an MIDI
        begin
          if edit_Wheel_PitchToMIDI >= (64 + c_pitchwheel_hyst) then
            temp_b:= edit_Wheel_PitchToMIDI
                  -  muldivByte(127 - edit_Wheel_PitchToMIDI, c_pitchwheel_hyst, 64)
          else if edit_Wheel_PitchToMIDI <= (64 - c_pitchwheel_hyst) then
            temp_b:= edit_Wheel_PitchToMIDI
                   + muldivByte(edit_Wheel_PitchToMIDI, c_pitchwheel_hyst, 64)
          else
            temp_b:= 64; // Mittelstellung
          MIDI_SendPitchwheel(0, temp_b);
        end;
      c_Wheel_PitchRotary: // MIDI Pitchwheel als Rotary Control
        begin
          if (edit_Wheel_PitchRotary > 96) and (edit_LogicalTab_LeslieFast = 0) then  // nur einmal senden
            NewEditIdxEvent(c_LogicalTab_LeslieFast, 255, event_source);
          if (edit_Wheel_PitchRotary < 32) and (edit_LogicalTab_LeslieFast <> 0) then
            NewEditIdxEvent(c_LogicalTab_LeslieFast, 0, event_source);
        end;
      c_Wheel_ModToMIDI:   // eigener Modwheel-Event an MIDI
        MIDI_SendController(0, 1, edit_Wheel_ModToMIDI); // MIDI Modulation
      c_Wheel_ModRotary:   // MIDI Modwheel als Rotary Control
        begin
          temp_b:= (edit_Wheel_ModRotary >= 64);
          if edit_LogicalTab_LeslieRun <> temp_b then // nur einmal senden
            NewEditIdxEvent(c_LogicalTab_LeslieRun, temp_b, event_source);
        end;
      end;
    end;
  end;
  if any_change then
    FillBlock(@event_array + c_Wheels, 4, 0);
end;

procedure AC_MomentaryControlsTimerElapsed;
begin
  ac_mb_dec:= false;
  ac_mb_inc:= false;
  ac_mb_v1:= false;
  ac_mb_v2:= false;
end;

// -----------------------------------------------------------------------------

procedure AC_HandleGatingknob;
// über Menü und aus Preset
var edit_idx: Word;
begin
  FillBlock(@edit_array + c_LogicalTab_H100_mode, 4, 0); // alle löschen
  if edit_GatingKnob > 0 then
    edit_array[c_LogicalTab_H100_mode + edit_GatingKnob - 1]:= 255;
  for edit_idx:= c_LogicalTab_H100_Mode to c_LogicalTab_EG_TimeBendMode do
    AC_sendmsg(edit_idx, c_control_event_source);     // zusätzlich senden
  AC_SendGating;
  MenuRefresh:= true;
end;

procedure AC_HandleGatingButtons;
begin
  // in AC_HandleGatingButtonsEvents behandelt
end;

procedure AC_HandleGatingButtonsEvents(event_idx, event_source: Word);
// Bedienelemente mit besonderen Funktionen, gegenseitig auslösende Tasten etc.
var
  edit_idx: Word;  my_bool: Boolean;
begin
  if event_source < c_editor_event_source then
    exit;  // Preset-Event, niederer FPGA-Event oder keiner

  case event_idx of
  c_LogicalTab_H100_Mode, c_LogicalTab_EG_Mode, // Gating-Buttons
  c_LogicalTab_EG_PercMode, c_LogicalTab_EG_TimeBendMode: // Gating-Buttons
    begin
      edit_GatingKnob:= 0;
      // Button wurde bereits invertiert!
      if edit_array[event_idx] then  // war vorher OFF
        case event_idx of
        c_LogicalTab_H100_mode: //
          edit_GatingKnob:= 1;
        c_LogicalTab_EG_mode: //
          edit_GatingKnob:= 2;
        c_LogicalTab_EG_PercMode: //
          edit_GatingKnob:= 3;
        c_LogicalTab_EG_TimeBendMode: //
          edit_GatingKnob:= 4;
        end;
      FillEventSource(c_LogicalTab_H100_mode, 4, 0); // wurden behandelt
      AC_HandleGatingknob;
      AC_sendmsg(c_GatingKnob, event_source);     // zusätzlich senden
      MenuRefresh:= true;
    end;
  end;
end;

// -----------------------------------------------------------------------------

procedure AC_HandleSaveEvents(event_idx, event_source: Word);
begin
  case event_idx of
  c_SaveEventDefaults: //
    SR_StoreDefaults;
  c_SaveEventOrganModel: //
    begin
      edit_OrganModel:= ValueTrimLimitB(edit_saveEventOrganModel, 0, 15);
      SR_StoreOrganModel(edit_OrganModel);
    end;
  c_SaveEventRotaryModel: //
    begin
      edit_RotaryModel:= ValueTrimLimitB(edit_saveEventRotaryModel, 0, 15);
      SR_StoreRotaryModel(edit_RotaryModel);
    end;
  c_SaveEventPreset: //
    begin
      edit_CommonPreset:= ValueTrimLimitB(edit_saveEventCommon, 0, 99);
      SR_SaveCommonPreset(edit_CommonPreset);
    end;
  c_SaveEventUpper: //
    begin
      edit_UpperVoice:= ValueTrimLimitB(edit_saveEventUpper, 0, 15);
      SR_SaveUpperVoice(edit_UpperVoice);
    end;
  c_SaveEventLower: //
    begin
      edit_LowerVoice:= ValueTrimLimitB(edit_saveEventLower, 0, 15);
      SR_SaveLowerVoice(edit_LowerVoice);
    end;
  c_SaveEventPedal: //
    begin
      edit_PedalVoice:= ValueTrimLimitB(edit_saveEventPedal, 0, 15);
      SR_SavePedalVoice(edit_PedalVoice);
    end;
  end;
  MSG_SaveDone;
  if event_source >= c_control_event_source then
    mDelay(1000); // falls MenuIndex_Splash gesetzt wird
end;

// #############################################################################
// ###                                                                       ###
// ###                    - + + E V E N T  L O O P + + -                     ###
// ###                                                                       ###
// #############################################################################

procedure AC_ExecEditChanges;
// Wird regelmäßig aus main_tasks-Zeitscheibe aufgerufen
// Geänderte Bedienelemente (*_flag > 0) als Message senden und über
// Proc-Tabelle ans FPGA bzw. entsprechende Routinen schicken
var
  event_source, event_idx, proc_idx: Word;
  run_proc: ^t_eventproc;
  preset_loaded: Word;
  // save_dest,
  control_type: Byte;
begin

  // alle Änderungen senden (neuer Wert <> alter Wert)
  // Änderungen nur im Touchpad-Set senden oder wenn mit Editor verbunden
  // wenn sich im Upper/Lower/Pedal-Menü Drawbars geändert haben
  AC_HandleChores;  // eep_xxx--Änderungen
  
  // Inc/Dec-Buttons vorab behandeln, könnten auch Presets und Voices ändern
  // Vibrato-Buttons vorab behandeln, nur von Bedienelementen oder MIDI
  AC_HandleNonSavedControlEvents; // mit control_type = c_ctrl_incdec
  
  // Vorab-Änderungen durch Presets/Voices/OrganModel/SpeakerModel
  preset_loaded:= AC_PresetVoiceOrganChanged;

  // Liste zu aktualisierender Parameter-Werte zusammenstellen,
  // Spezial-Buttons müssen einzeln vorab ausgeführt werden
  FillBlock(@ac_proclist_flags, sizeof(ac_proclist_flags), 0); // Liste löschen

  for event_idx:= 0 to c_edit_array_len-1 do begin
    event_source:= event_array[event_idx];
    if event_source = 0 then
      continue;
    event_array[event_idx]:= 0; // Event wurde behandelt

    if event_source = c_control_event_source then
      // könnte sich in AC_HandleMomentaryControls nachträglich ändern
      MenuIndex_SplashIfEnabled:= EditIdx2MenuInverseArray[event_idx];

    If ValueInRange(event_idx, c_OrganModel, c_PedalVoice) then
      continue;   // wurden ggf. durch Laden des Presets bereits behandelt



    // eigene Änderungen von Preset oder Bedienelement senden
    if (event_source > c_board_event_source) then begin
      temp_w:= c_SaveRestoreMasks[event_idx];
      // save_dest:= hi(temp_w) and $0F;  // unteres Nibble
      control_type:= hi(temp_w) shr 4; // oberes Nibble
      case control_type of
      c_controlTypeMomentary, c_controlTypeButtonToKnob:   //
        AC_HandleGatingButtonsEvents(event_idx, event_source);
//    c_ctrl_knob:   //
//      AC_HandleKnobEvents(event_idx, event_source);
      c_controlTypeSaveEnter: //
        if event_source >= c_editor_event_source then
          AC_HandleSaveEvents(event_idx, event_source);
      end;
      // Event aussenden an Manager oder OSC
      AC_sendmsg(event_idx, event_source);
    end;

    // Änderungen für FPGA und DSP
    proc_idx:= ac_proc_idx[event_idx];
    if proc_idx < c_proc_max then
      ac_proclist_flags[proc_idx]:= 255;
    if (event_source <> c_menu_event_source)
    and (event_source > c_to_fpga_event_source) then
      MenuRefresh:= true;
  end;
  
  // akkumulierte Routinen in vorgegebener Reihenfolge durchgehen
  for proc_idx:= 0 to c_proc_max do
    if ac_proclist_flags[proc_idx] then begin  // Event ausgelöst?
      run_proc:= ac_event_procs[proc_idx];
      if run_proc <> nil then
        run_proc^;
    end;
  if preset_loaded >= 3 then
    PresetInvalids[0]:= false;  // Common Preset wurde geladen, gültig

  if issystimerzero(c_MomentaryTimer) then
    AC_MomentaryControlsTimerElapsed;

end;

procedure AC_Init;
begin
  ReverbKnob_old:= 255;
{$IFDEF DEBUG_INITS}
  Serial1_sendstringCRLF('/ AC Init ');
{$ENDIF}
  MIDI_DisablePercussion:= false;
  MIDI_OverrideCancelDB1:= false;
  FillBlock(@ExtendedEvents, sizeof(ExtendedEvents), 0);
  ExtendedEvents[c_extevt_SendLeslieInits]:=  true;  // außerhalb Event-Tabelle
  ExtendedEvents[c_extevt_SendBusbarInits]:=  true;
  ExtendedEvents[c_extevt_SendPhasingInits]:= true;
  // Single to Upper-Button ausführen
  event_array[c_LogicalTab_SingleDBtoUpper]:= true;
  ac_swell_integrator_w:= 0;  ac_volume_integrator_w:= 0;
  ac_swell_w:= 0; ac_volume_w:= 0;
  ac_swell_w_old:= 0; ac_volume_w_old:= 0;

  AC_ExecEditChanges;
  AC_SendSwell;
  FillBlock(@PresetInvalids, sizeof(PresetInvalids), 0);
end;

end.